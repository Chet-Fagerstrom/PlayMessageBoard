[0m2021.03.15 21:21:22 INFO  Started: Metals version 0.10.0 in workspace 'C:\Users\Chet\WebApps\messageboard' for client vscode 1.54.3.[0m
[0m2021.03.15 21:21:23 INFO  time: initialize in 0.3s[0m
[0m2021.03.15 21:21:23 WARN  Build server is not auto-connectable.[0m
[0m2021.03.15 21:21:27 INFO  running 'C:\Program Files\Java\jdk1.8.0_191\bin\java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\Chet\AppData\Local\Temp\metals2860726220361307238\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'[0m
[0m2021.03.15 21:21:29 INFO  [info] welcome to sbt 1.3.13 (Oracle Corporation Java 1.8.0_191)[0m
[0m2021.03.15 21:21:31 INFO  [info] loading settings for project messageboard-build-build-build from metals.sbt ...[0m
[0m2021.03.15 21:21:31 INFO  [info] loading project definition from C:\Users\Chet\WebApps\messageboard\project\project\project[0m
[0m2021.03.15 21:21:33 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.15 21:21:33 INFO  [info] loading settings for project messageboard-build-build from metals.sbt ...[0m
[0m2021.03.15 21:21:34 INFO  [info] loading project definition from C:\Users\Chet\WebApps\messageboard\project\project[0m
[0m2021.03.15 21:21:34 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.15 21:21:35 INFO  [success] Generated .bloop\messageboard-build-build.json[0m
[0m2021.03.15 21:21:35 INFO  [success] Total time: 1 s, completed Mar 15, 2021 9:21:35 PM[0m
[0m2021.03.15 21:21:35 INFO  [info] loading settings for project messageboard-build from metals.sbt,plugins.sbt ...[0m
[0m2021.03.15 21:21:35 INFO  [info] loading project definition from C:\Users\Chet\WebApps\messageboard\project[0m
[0m2021.03.15 21:21:37 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.15 21:21:37 INFO  [success] Generated .bloop\messageboard-build.json[0m
[0m2021.03.15 21:21:39 INFO  [success] Total time: 2 s, completed Mar 15, 2021 9:21:39 PM[0m
[0m2021.03.15 21:21:41 INFO  [info] loading settings for project root from build.sbt ...[0m
[0m2021.03.15 21:21:41 INFO  [info] set current project to MessageBoard (in build file:/C:/Users/Chet/WebApps/messageboard/)[0m
[0m2021.03.15 21:21:44 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.15 21:21:46 INFO  [warn] There may be incompatibilities among your library dependencies; run 'evicted' to see detailed eviction warnings.[0m
[0m2021.03.15 21:21:46 INFO  [success] Generated .bloop\root.json[0m
[0m2021.03.15 21:21:46 INFO  [success] Generated .bloop\root-test.json[0m
[0m2021.03.15 21:21:46 INFO  [success] Total time: 4 s, completed Mar 15, 2021 9:21:47 PM[0m
[0m2021.03.15 21:21:46 INFO  sbt bloopInstall exit: 0[0m
[0m2021.03.15 21:21:47 INFO  time: ran 'sbt bloopInstall' in 19s[0m
[0m2021.03.15 21:21:47 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 39510'...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
No server running at 127.0.0.1:8212, let's fire one...
Resolving ch.epfl.scala:bloop-frontend_2.12:1.4.8...
Starting bloop server at 127.0.0.1:8212...
Attempting a connection to the server...
[0m[32m[D][0m Loading 2 projects from 'c:\Users\Chet\WebApps\messageboard\.bloop'...
[0m[32m[D][0m Loading project from 'c:\Users\Chet\WebApps\messageboard\.bloop\root.json'
[0m[32m[D][0m Loading project from 'c:\Users\Chet\WebApps\messageboard\.bloop\root-test.json'
[0m[32m[D][0m Cache miss for scala instance org.scala-lang:scala-compiler:2.13.3.
[0m[32m[D][0m   => C:\Users\Chet\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\net\java\dev\jna\jna\5.3.1\jna-5.3.1.jar
[0m[32m[D][0m   => C:\Users\Chet\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\jline\jline\3.15.0\jline-3.15.0.jar
[0m[32m[D][0m   => C:\Users\Chet\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-compiler\2.13.3\scala-compiler-2.13.3.jar
[0m[32m[D][0m   => C:\Users\Chet\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.13.3\scala-library-2.13.3.jar
[0m[32m[D][0m   => C:\Users\Chet\AppData\Local\Coursier\cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-reflect\2.13.3\scala-reflect-2.13.3.jar
[0m[32m[D][0m Missing analysis file for project 'root-test'
[0m[32m[D][0m Missing analysis file for project 'root'
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:39510...
The server is listening for incoming connections at tcp://127.0.0.1:39510...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.15 21:21:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Chet\AppData\Local\scalameta\metals\cache\bsp.trace.json[0m
[0m2021.03.15 21:21:55 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 37992'...
[0m2021.03.15 21:21:55 INFO  Attempting to connect to the build server...[0m
Waiting for the bsp connection to come up...
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol tcp --port 43452'...
Waiting for the bsp connection to come up...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:37992...
The server is listening for incoming connections at tcp://127.0.0.1:37992...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m[32m[D][0m Loading workspace settings from bloop.settings.json
[0m[32m[D][0m Waiting for a connection at 127.0.0.1:43452...
The server is listening for incoming connections at tcp://127.0.0.1:43452...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.15 21:21:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Chet\AppData\Local\scalameta\metals\cache\bsp.trace.json[0m
[0m2021.03.15 21:21:55 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Chet\AppData\Local\scalameta\metals\cache\bsp.trace.json[0m
[0m2021.03.15 21:21:55 INFO  time: Connected to build server in 8.66s[0m
[0m2021.03.15 21:21:55 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.15 21:21:55 INFO  time: Imported build in 0.13s[0m
[0m2021.03.15 21:22:02 INFO  time: indexed workspace in 6.16s[0m
[0m2021.03.15 21:22:22 INFO  compiling root (7 scala sources and 1 java source)[0m
[0m2021.03.15 21:22:32 INFO  time: compiled root in 9.93s[0m
[0m2021.03.15 21:24:10 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 21:24:10 INFO  time: compiled root in 0.22s[0m
[0m2021.03.15 21:25:17 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 21:25:17 INFO  time: compiled root in 0.68s[0m
[0m2021.03.15 21:52:35 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 21:52:35 INFO  time: compiled root in 0.83s[0m
[0m2021.03.15 22:03:46 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:03:46 INFO  time: compiled root in 0.82s[0m
[0m2021.03.15 22:04:21 INFO  compiling root (10 scala sources and 2 java sources)[0m
[0m2021.03.15 22:04:21 INFO  time: compiled root in 0.32s[0m
[0m2021.03.15 22:04:41 INFO  compiling root (8 scala sources and 1 java source)[0m
[0m2021.03.15 22:04:41 INFO  time: compiled root in 0.34s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import javax.inject.Inject
import play.api.data.FormBinding
import play.api.http._
import play.api.i18n.Langs
import play.api.i18n.MessagesApi
import play.twirl.api.Html

import scala.concurrent.ExecutionContext

/**
 * Useful mixins for controller classes.
 *
 * If you wish to write a controller with minimal dependencies, you can mix in this trait, which includes helpers and
 * useful constants.
 *
 * {{{
 *   class MyController @Inject() (action: DefaultActionBuilder, parse: PlayBodyParsers) extends ControllerHelpers {
 *     def index = action(parse.text) {
 *       Ok
 *     }
 *   }
 * }}}
 */
trait ControllerHelpers
    extends Results
    with HttpProtocol
    with Status
    with HeaderNames
    with ContentTypes
    with RequestExtractors
    with Rendering
    with RequestImplicits {

  /**
   * Used to mark an action that is still not implemented, e.g.:
   *
   * {{{
   *   def action(query: String) = TODO
   * }}}
   */
  lazy val TODO: Action[AnyContent] = ActionBuilder.ignoringBody { implicit request =>
    NotImplemented[Html](views.html.defaultpages.todo())
  }
}

object ControllerHelpers extends ControllerHelpers

/**
 * Useful prewired mixins for controller components, assuming an available [[ControllerComponents]].
 *
 * If you want to extend your own [[AbstractController]] but want to use a different base "Action",
 * you can mix in this trait.
 */
trait BaseControllerHelpers extends ControllerHelpers {

  /**
   * The components needed to use the controller methods
   */
  protected def controllerComponents: ControllerComponents

  /**
   * The default body parsers provided by Play. This can be used along with the Action helper to customize the body
   * parser, for example:
   *
   * {{{
   *   def foo(query: String) = Action(parse.tolerantJson) { request =>
   *     Ok(request.body)
   *   }
   * }}}
   */
  def parse: PlayBodyParsers = controllerComponents.parsers

  implicit lazy val defaultFormBinding: FormBinding = parse.formBinding(parse.DefaultMaxTextLength)

  /**
   * The default execution context provided by Play. You should use this for non-blocking code only. You can do so by
   * passing it explicitly, or by defining an implicit in your controller like so:
   *
   * {{{
   *   implicit lazy val executionContext = defaultExecutionContext
   * }}}
   */
  def defaultExecutionContext: ExecutionContext = controllerComponents.executionContext

  /**
   * The MessagesApi provided by Play. This can be used to provide the MessagesApi needed by play.api.i18n.I18nSupport.
   */
  implicit def messagesApi: MessagesApi = controllerComponents.messagesApi

  /**
   * The default Langs provided by Play. Can be used to determine the application's supported languages.
   */
  implicit def supportedLangs: Langs = controllerComponents.langs

  /**
   * The default FileMimeTypes provided by Play. Used to map between file name extensions and mime types.
   */
  implicit def fileMimeTypes: FileMimeTypes = controllerComponents.fileMimeTypes
}

/**
 * Useful mixin for methods that do implicit transformations of a request
 */
trait RequestImplicits {

  /**
   * Retrieves the session implicitly from the request.
   *
   * For example:
   * {{{
   * def index(name:String) = Action { implicit request =>
   *   val username = request2session("username")
   *   Ok("Hello " + username)
   * }
   * }}}
   */
  implicit def request2session(implicit request: RequestHeader): Session = request.session

  /**
   * Retrieve the flash scope implicitly from the request.
   *
   * For example:
   * {{{
   * def index(name:String) = Action { implicit request =>
   *   val message = request2flash("message")
   *   Ok("Got " + message)
   * }
   * }}}
   */
  implicit def request2flash(implicit request: RequestHeader): Flash = request.flash
}

/**
 * Defines utility methods to generate `Action` and `Results` types.
 *
 * For example:
 * {{{
 * class HomeController @Inject() (val controllerComponents: ControllerComponents) extends BaseController {
 *
 *   def hello(name:String) = Action { request =>
 *     Ok("Hello " + name)
 *   }
 *
 * }
 * }}}
 *
 *
 * This is intended to provide the idiomatic Play API for actions, allowing you to use "Action" for the default
 * action builder and "parse" to access Play's default body parsers. You may want to extend this to provide your own
 * base controller class, or write your own version with similar code.
 */
trait BaseController extends BaseControllerHelpers {

  /**
   * The default ActionBuilder. Used to construct an action, for example:
   *
   * {{{
   *   def foo(query: String) = Action {
   *     Ok
   *   }
   * }}}
   *
   * This is meant to be a replacement for the now-deprecated Action object, and can be used in the same way.
   */
  def Action: ActionBuilder[Request, AnyContent] = controllerComponents.actionBuilder
}

/**
 * An abstract implementation of [[BaseController]] to make it slightly easier to use.
 */
abstract class AbstractController(protected val controllerComponents: ControllerComponents) extends BaseController

/**
 * A variation of [[BaseController]] that gets its components via method injection.
 */
trait InjectedController extends BaseController {
  private[this] var _components: ControllerComponents = _

  protected override def controllerComponents: ControllerComponents = {
    if (_components == null) fallbackControllerComponents else _components
  }

  /**
   * Call this method to set the [[ControllerComponents]] instance.
   */
  @Inject
  def setControllerComponents(components: ControllerComponents): Unit = {
    _components = components
  }

  /**
   * Defines fallback components to use in case setControllerComponents has not been called.
   */
  protected def fallbackControllerComponents: ControllerComponents = {
    throw new NoSuchElementException(
      "ControllerComponents not set! Call setControllerComponents or create the instance with dependency injection."
    )
  }
}

/**
 * A variation of [[MessagesAbstractController]] that gets its components via method injection.
 */
trait MessagesInjectedController extends MessagesBaseController {
  private[this] var _components: MessagesControllerComponents = _

  protected override def controllerComponents: MessagesControllerComponents = {
    if (_components == null) fallbackControllerComponents else _components
  }

  /**
   * Call this method to set the [[ControllerComponents]] instance.
   */
  @Inject
  def setControllerComponents(components: MessagesControllerComponents): Unit = {
    _components = components
  }

  /**
   * Defines fallback components to use in case setControllerComponents has not been called.
   */
  protected def fallbackControllerComponents: MessagesControllerComponents = {
    throw new NoSuchElementException(
      "ControllerComponents not set! Call setControllerComponents or create the instance with dependency injection."
    )
  }
}

/**
 * The base controller components dependencies that most controllers rely on.
 */
trait ControllerComponents {
  def actionBuilder: ActionBuilder[Request, AnyContent]
  def parsers: PlayBodyParsers
  def messagesApi: MessagesApi
  def langs: Langs
  def fileMimeTypes: FileMimeTypes
  def executionContext: scala.concurrent.ExecutionContext
}

case class DefaultControllerComponents @Inject() (
    actionBuilder: DefaultActionBuilder,
    parsers: PlayBodyParsers,
    messagesApi: MessagesApi,
    langs: Langs,
    fileMimeTypes: FileMimeTypes,
    executionContext: scala.concurrent.ExecutionContext
) extends ControllerComponents

[0m2021.03.15 22:06:52 INFO  compiling root (8 scala sources and 1 java source)[0m
[0m2021.03.15 22:06:54 INFO  time: compiled root in 1.99s[0m
[0m2021.03.15 22:07:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:07:33 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:08:56 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:08:56 INFO  time: compiled root in 0.65s[0m
[0m2021.03.15 22:10:37 INFO  compiling root (8 scala sources and 1 java source)[0m
[0m2021.03.15 22:10:38 INFO  time: compiled root in 1.51s[0m
[0m2021.03.15 22:11:09 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:11:09 INFO  time: compiled root in 0.77s[0m
[0m2021.03.15 22:15:17 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:15:17 INFO  time: compiled root in 0.12s[0m
[0m2021.03.15 22:17:10 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:17:10 INFO  time: compiled root in 0.18s[0m
[0m2021.03.15 22:17:14 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:17:14 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:17:53 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:17:53 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:17:55 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:17:55 INFO  time: compiled root in 81ms[0m
[0m2021.03.15 22:17:58 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:17:58 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:18:06 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:18:06 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:18:23 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:18:23 INFO  time: compiled root in 77ms[0m
[0m2021.03.15 22:19:48 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:19:48 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:20:23 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:20:23 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 22:20:32 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:20:32 INFO  time: compiled root in 0.15s[0m
[0m2021.03.15 22:20:39 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:20:39 INFO  time: compiled root in 0.13s[0m
[0m2021.03.15 22:21:01 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:21:01 INFO  time: compiled root in 77ms[0m
[0m2021.03.15 22:21:04 INFO  compiling root (3 scala sources)[0m
[0m2021.03.15 22:21:04 INFO  time: compiled root in 0.13s[0m
[0m2021.03.15 22:21:34 INFO  compiling root (2 scala sources)[0m
[0m2021.03.15 22:21:34 WARN  unexpected error processing the file C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\target\scala-2.13\twirl\main\views\html\login.template.scala.semanticdb
java.nio.file.FileSystemException: C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\target\scala-2.13\twirl\main\views\html\login.template.scala.semanticdb: The process cannot access the file because it is being used by another process.

	at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:86)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)
	at sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:230)
	at java.nio.file.Files.newByteChannel(Files.java:361)
	at java.nio.file.Files.newByteChannel(Files.java:407)
	at java.nio.file.Files.readAllBytes(Files.java:3152)
	at scala.meta.internal.metals.SemanticdbIndexer.onChange(SemanticdbIndexer.scala:96)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChangeWatchedFiles$5(MetalsLanguageServer.scala:1220)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[0m
[0m2021.03.15 22:21:34 INFO  time: compiled root in 0.67s[0m
[0m2021.03.15 22:24:13 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:24:13 INFO  time: compiled root in 0.27s[0m
Mar 15, 2021 10:24:50 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 15, 2021 10:24:50 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

[0m2021.03.15 22:29:54 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:29:54 INFO  time: compiled root in 0.57s[0m
Mar 15, 2021 10:35:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3372
[0m2021.03.15 22:35:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:35:33 INFO  time: compiled root in 0.11s[0m
[0m2021.03.15 22:35:44 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:35:44 INFO  time: compiled root in 78ms[0m
[0m2021.03.15 22:35:57 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:35:57 INFO  time: compiled root in 0.12s[0m
[0m2021.03.15 22:37:23 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.15 22:37:25 INFO  time: compiled root in 1.55s[0m
Mar 15, 2021 10:37:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3557
Mar 15, 2021 10:38:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3581
Mar 15, 2021 10:38:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3587
[0m2021.03.15 22:38:30 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:38:30 INFO  time: compiled root in 0.69s[0m
[0m2021.03.15 22:39:17 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:39:17 INFO  time: compiled root in 0.78s[0m
[0m2021.03.15 22:39:37 INFO  compiling root-test (1 scala source)[0m
[0m2021.03.15 22:39:37 INFO  time: compiled root-test in 0.82s[0m
[0m2021.03.15 22:39:42 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:39:43 WARN  unexpected error processing the file C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\app\models\MessageBoardInMemoryModel.scala.semanticdb
java.nio.file.FileSystemException: C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\app\models\MessageBoardInMemoryModel.scala.semanticdb: The process cannot access the file because it is being used by another process.

	at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:86)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)
	at sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:230)
	at java.nio.file.Files.newByteChannel(Files.java:361)
	at java.nio.file.Files.newByteChannel(Files.java:407)
	at java.nio.file.Files.readAllBytes(Files.java:3152)
	at scala.meta.internal.metals.SemanticdbIndexer.onChange(SemanticdbIndexer.scala:96)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChangeWatchedFiles$5(MetalsLanguageServer.scala:1220)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[0m
[0m2021.03.15 22:39:42 INFO  time: compiled root in 0.63s[0m
Mar 15, 2021 10:39:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3739
Mar 15, 2021 10:40:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3750
Mar 15, 2021 10:40:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3757
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala

object Option {

  import scala.language.implicitConversions

  /** An implicit conversion that converts an option to an iterable value
   */
  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] = xo.toList

  /** An Option factory which creates Some(x) if the argument is not null,
   *  and None if it is null.
   *
   *  @param  x the value
   *  @return   Some(value) if value != null, None if value == null
   */
  def apply[A](x: A): Option[A] = if (x == null) None else Some(x)

  /** An Option factory which returns `None` in a manner consistent with
   *  the collections hierarchy.
   */
  def empty[A] : Option[A] = None
}

/** Represents optional values. Instances of `Option`
 *  are either an instance of $some or the object $none.
 *
 *  The most idiomatic way to use an $option instance is to treat it
 *  as a collection or monad and use `map`,`flatMap`, `filter`, or
 *  `foreach`:
 *
 *  {{{
 *  val name: Option[String] = request getParameter "name"
 *  val upper = name map { _.trim } filter { _.length != 0 } map { _.toUpperCase }
 *  println(upper getOrElse "")
 *  }}}
 *
 *  Note that this is equivalent to {{{
 *  val upper = for {
 *    name <- request getParameter "name"
 *    trimmed <- Some(name.trim)
 *    upper <- Some(trimmed.toUpperCase) if trimmed.length != 0
 *  } yield upper
 *  println(upper getOrElse "")
 *  }}}
 *
 *  Because of how for comprehension works, if $none is returned
 *  from `request.getParameter`, the entire expression results in
 *  $none
 *
 *  This allows for sophisticated chaining of $option values without
 *  having to check for the existence of a value.
 *
 * These are useful methods that exist for both $some and $none.
 *  - [[isDefined]] — True if not empty
 *  - [[isEmpty]] — True if empty
 *  - [[nonEmpty]] — True if not empty
 *  - [[orElse]] — Evaluate and return alternate optional value if empty
 *  - [[getOrElse]] — Evaluate and return alternate value if empty
 *  - [[get]] — Return value, throw exception if empty
 *  - [[fold]] —  Apply function on optional value, return default if empty
 *  - [[map]] — Apply a function on the optional value
 *  - [[flatMap]] — Same as map but function must return an optional value
 *  - [[foreach]] — Apply a procedure on option value
 *  - [[collect]] — Apply partial pattern match on optional value
 *  - [[filter]] — An optional value satisfies predicate
 *  - [[filterNot]] — An optional value doesn't satisfy predicate
 *  - [[exists]] — Apply predicate on optional value, or false if empty
 *  - [[forall]] — Apply predicate on optional value, or true if empty
 *  - [[contains]] — Checks if value equals optional value, or false if empty
 *  - [[toList]] — Unary list of optional value, otherwise the empty list
 *
 *  A less-idiomatic way to use $option values is via pattern matching: {{{
 *  val nameMaybe = request getParameter "name"
 *  nameMaybe match {
 *    case Some(name) =>
 *      println(name.trim.toUppercase)
 *    case None =>
 *      println("No name value")
 *  }
 *  }}}
 *
 * Interacting with code that can occasionally return null can be
 * safely wrapped in $option to become $none and $some otherwise. {{{
 * val abc = new java.util.HashMap[Int, String]
 * abc.put(1, "A")
 * bMaybe = Option(abc.get(2))
 * bMaybe match {
 *   case Some(b) =>
 *     println(s"Found \$b")
 *   case None =>
 *     println("Not found")
 * }
 * }}}
 *
 *  @note Many of the methods in here are duplicative with those
 *  in the Traversable hierarchy, but they are duplicated for a reason:
 *  the implicit conversion tends to leave one with an Iterable in
 *  situations where one could have retained an Option.
 *
 *  @author  Martin Odersky
 *  @author  Matthias Zenger
 *  @since   1.1
 *  @define none `None`
 *  @define some [[scala.Some]]
 *  @define option [[scala.Option]]
 *  @define p `p`
 *  @define f `f`
 *  @define coll option
 *  @define Coll `Option`
 *  @define orderDependent
 *  @define orderDependentFold
 *  @define mayNotTerminateInf
 *  @define willNotTerminateInf
 *  @define collectExample
 *  @define undefinedorder
 *  @define thatinfo the class of the returned collection. In the standard library configuration, `That` is `Iterable[B]`
 *  @define bfinfo an implicit value of class `CanBuildFrom` which determines the result class `That` from the current
 *    representation type `Repr` and the new element type `B`.
 */
@SerialVersionUID(-114498752079829388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
sealed abstract class Option[+A] extends Product with Serializable {
  self =>

  /** Returns true if the option is $none, false otherwise.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(_) => false
   *   case None    => true
   * }
   * }}}
   */
  def isEmpty: Boolean

  /** Returns true if the option is an instance of $some, false otherwise.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(_) => true
   *   case None    => false
   * }
   * }}}
   */
  def isDefined: Boolean = !isEmpty

  /** Returns the option's value.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x
   *   case None    => throw new Exception
   * }
   * }}}
   *  @note The option must be nonempty.
   *  @throws java.util.NoSuchElementException if the option is empty.
   */
  def get: A

  /** Returns the option's value if the option is nonempty, otherwise
   * return the result of evaluating `default`.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x
   *   case None    => default
   * }
   * }}}
   *
   *  @param default  the default expression.
   */
  @inline final def getOrElse[B >: A](default: => B): B =
    if (isEmpty) default else this.get

  /** Returns the option's value if it is nonempty,
   * or `null` if it is empty.
   *
   * Although the use of null is discouraged, code written to use
   * $option must often interface with code that expects and returns nulls.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x
   *   case None    => null
   * }
   * }}}
   * @example {{{
   * val initialText: Option[String] = getInitialText
   * val textField = new JComponent(initialText.orNull,20)
   * }}}
   */
  @inline final def orNull[A1 >: A](implicit ev: Null <:< A1): A1 = this getOrElse ev(null)

  /** Returns a $some containing the result of applying $f to this $option's
   * value if this $option is nonempty.
   * Otherwise return $none.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Some(f(x))
   *   case None    => None
   * }
   * }}}
   *  @note This is similar to `flatMap` except here,
   *  $f does not need to wrap its result in an $option.
   *
   *  @param  f   the function to apply
   *  @see flatMap
   *  @see foreach
   */
  @inline final def map[B](f: A => B): Option[B] =
    if (isEmpty) None else Some(f(this.get))

  /** Returns the result of applying $f to this $option's
   *  value if the $option is nonempty.  Otherwise, evaluates
   *  expression `ifEmpty`.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => f(x)
   *   case None    => ifEmpty
   * }
   * }}}
   * This is also equivalent to:
   * {{{
   * option map f getOrElse ifEmpty
   * }}}
   *  @param  ifEmpty the expression to evaluate if empty.
   *  @param  f       the function to apply if nonempty.
   */
  @inline final def fold[B](ifEmpty: => B)(f: A => B): B =
    if (isEmpty) ifEmpty else f(this.get)

  /** Returns the result of applying $f to this $option's value if
   * this $option is nonempty.
   * Returns $none if this $option is empty.
   * Slightly different from `map` in that $f is expected to
   * return an $option (which could be $none).
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => f(x)
   *   case None    => None
   * }
   * }}}
   *  @param  f   the function to apply
   *  @see map
   *  @see foreach
   */
  @inline final def flatMap[B](f: A => Option[B]): Option[B] =
    if (isEmpty) None else f(this.get)

  def flatten[B](implicit ev: A <:< Option[B]): Option[B] =
    if (isEmpty) None else ev(this.get)

  /** Returns this $option if it is nonempty '''and''' applying the predicate $p to
   * this $option's value returns true. Otherwise, return $none.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) if p(x) => Some(x)
   *   case _               => None
   * }
   * }}}
   *  @param  p   the predicate used for testing.
   */
  @inline final def filter(p: A => Boolean): Option[A] =
    if (isEmpty || p(this.get)) this else None

  /** Returns this $option if it is nonempty '''and''' applying the predicate $p to
   * this $option's value returns false. Otherwise, return $none.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) if !p(x) => Some(x)
   *   case _                => None
   * }
   * }}}
   *  @param  p   the predicate used for testing.
   */
  @inline final def filterNot(p: A => Boolean): Option[A] =
    if (isEmpty || !p(this.get)) this else None

  /** Returns false if the option is $none, true otherwise.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(_) => true
   *   case None    => false
   * }
   * }}}
   *  @note   Implemented here to avoid the implicit conversion to Iterable.
   */
  final def nonEmpty = isDefined

  /** Necessary to keep $option from being implicitly converted to
   *  [[scala.collection.Iterable]] in `for` comprehensions.
   */
  @inline final def withFilter(p: A => Boolean): WithFilter = new WithFilter(p)

  /** We need a whole WithFilter class to honor the "doesn't create a new
   *  collection" contract even though it seems unlikely to matter much in a
   *  collection with max size 1.
   */
  class WithFilter(p: A => Boolean) {
    def map[B](f: A => B): Option[B] = self filter p map f
    def flatMap[B](f: A => Option[B]): Option[B] = self filter p flatMap f
    def foreach[U](f: A => U): Unit = self filter p foreach f
    def withFilter(q: A => Boolean): WithFilter = new WithFilter(x => p(x) && q(x))
  }

  /** Tests whether the option contains a given value as an element.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => x == elem
   *   case None    => false
   * }
   * }}}
   *  @example {{{
   *  // Returns true because Some instance contains string "something" which equals "something".
   *  Some("something") contains "something"
   *
   *  // Returns false because "something" != "anything".
   *  Some("something") contains "anything"
   *
   *  // Returns false when method called on None.
   *  None contains "anything"
   *  }}}
   *
   *  @param elem the element to test.
   *  @return `true` if the option has an element that is equal (as
   *  determined by `==`) to `elem`, `false` otherwise.
   */
  final def contains[A1 >: A](elem: A1): Boolean =
    !isEmpty && this.get == elem

  /** Returns true if this option is nonempty '''and''' the predicate
   * $p returns true when applied to this $option's value.
   * Otherwise, returns false.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => p(x)
   *   case None    => false
   * }
   * }}}
   *  @param  p   the predicate to test
   */
  @inline final def exists(p: A => Boolean): Boolean =
    !isEmpty && p(this.get)

  /** Returns true if this option is empty '''or''' the predicate
   * $p returns true when applied to this $option's value.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => p(x)
   *   case None    => true
   * }
   * }}}
   *  @param  p   the predicate to test
   */
  @inline final def forall(p: A => Boolean): Boolean = isEmpty || p(this.get)

  /** Apply the given procedure $f to the option's value,
   *  if it is nonempty. Otherwise, do nothing.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => f(x)
   *   case None    => ()
   * }
   * }}}
   *  @param  f   the procedure to apply.
   *  @see map
   *  @see flatMap
   */
  @inline final def foreach[U](f: A => U) {
    if (!isEmpty) f(this.get)
  }

  /** Returns a $some containing the result of
   * applying `pf` to this $option's contained
   * value, '''if''' this option is
   * nonempty '''and''' `pf` is defined for that value.
   * Returns $none otherwise.
   *
   *  @example {{{
   *  // Returns Some(HTTP) because the partial function covers the case.
   *  Some("http") collect {case "http" => "HTTP"}
   *
   *  // Returns None because the partial function doesn't cover the case.
   *  Some("ftp") collect {case "http" => "HTTP"}
   *
   *  // Returns None because the option is empty. There is no value to pass to the partial function.
   *  None collect {case value => value}
   *  }}}
   *
   *  @param  pf   the partial function.
   *  @return the result of applying `pf` to this $option's
   *  value (if possible), or $none.
   */
  @inline final def collect[B](pf: PartialFunction[A, B]): Option[B] =
    if (!isEmpty) pf.lift(this.get) else None

  /** Returns this $option if it is nonempty,
   *  otherwise return the result of evaluating `alternative`.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Some(x)
   *   case None    => alternative
   * }
   * }}}
   *  @param alternative the alternative expression.
   */
  @inline final def orElse[B >: A](alternative: => Option[B]): Option[B] =
    if (isEmpty) alternative else this

  /** Returns a singleton iterator returning the $option's value
   * if it is nonempty, or an empty iterator if the option is empty.
   */
  def iterator: Iterator[A] =
    if (isEmpty) collection.Iterator.empty else collection.Iterator.single(this.get)

  /** Returns a singleton list containing the $option's value
   * if it is nonempty, or the empty list if the $option is empty.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => List(x)
   *   case None    => Nil
   * }
   * }}}
   */
  def toList: List[A] =
    if (isEmpty) List() else new ::(this.get, Nil)

  /** Returns a [[scala.util.Left]] containing the given
   * argument `left` if this $option is empty, or
   * a [[scala.util.Right]] containing this $option's value if
   * this is nonempty.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Right(x)
   *   case None    => Left(left)
   * }
   * }}}
   * @param left the expression to evaluate and return if this is empty
   * @see toLeft
   */
  @inline final def toRight[X](left: => X): Either[X, A] =
    if (isEmpty) Left(left) else Right(this.get)

  /** Returns a [[scala.util.Right]] containing the given
   * argument `right` if this is empty, or
   * a [[scala.util.Left]] containing this $option's value
   * if this $option is nonempty.
   *
   * This is equivalent to:
   * {{{
   * option match {
   *   case Some(x) => Left(x)
   *   case None    => Right(right)
   * }
   * }}}
   * @param right the expression to evaluate and return if this is empty
   * @see toRight
   */
  @inline final def toLeft[X](right: => X): Either[A, X] =
    if (isEmpty) Right(right) else Left(this.get)
}

/** Class `Some[A]` represents existing values of type
 *  `A`.
 *
 *  @author  Martin Odersky
 *  @since   1.0
 */
@SerialVersionUID(1234815782226070388L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
final case class Some[+A](@deprecatedName('x, "2.12.0") value: A) extends Option[A] {
  def isEmpty = false
  def get = value

  @deprecated("Use .value instead.", "2.12.0") def x: A = value
}


/** This case object represents non-existent values.
 *
 *  @author  Martin Odersky
 *  @since   1.0
 */
@SerialVersionUID(5066590221178148012L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
case object None extends Option[Nothing] {
  def isEmpty = true
  def get = throw new NoSuchElementException("None.get")
}

[0m2021.03.15 22:40:57 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:40:57 INFO  time: compiled root in 0.7s[0m
Mar 15, 2021 10:44:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3887
[0m2021.03.15 22:44:23 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:44:23 INFO  time: compiled root in 0.61s[0m
something's wrong: no file:///C:/Users/Chet/WebApps/messageboard/app/models/MessageBoardInMemoryModel.scala in scala.collection.mutable.Map[String,<error>]RangePosition(file:///C:/Users/Chet/WebApps/messageboard/app/models/MessageBoardInMemoryModel.scala, 378, 386, 406)
[0m2021.03.15 22:50:25 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:50:25 INFO  time: compiled root in 0.1s[0m
something's wrong: no file:///C:/Users/Chet/WebApps/messageboard/app/models/MessageBoardInMemoryModel.scala in (String, String)RangePosition(file:///C:/Users/Chet/WebApps/messageboard/app/models/MessageBoardInMemoryModel.scala, 340, 340, 437)
[0m2021.03.15 22:52:43 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:52:43 INFO  time: compiled root in 0.1s[0m
[0m2021.03.15 22:52:54 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:52:54 INFO  time: compiled root in 0.6s[0m
[0m2021.03.15 22:56:20 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:56:20 INFO  time: compiled root in 0.65s[0m
Mar 15, 2021 10:56:30 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 15, 2021 10:56:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

[0m2021.03.15 22:57:36 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 22:57:36 INFO  time: compiled root in 0.75s[0m
Mar 15, 2021 10:57:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5879
[0m2021.03.15 23:02:04 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:02:04 INFO  time: compiled root in 0.12s[0m
[0m2021.03.15 23:02:44 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:02:44 INFO  time: compiled root in 0.13s[0m
[0m2021.03.15 23:08:48 INFO  compiling root (2 scala sources)[0m
[0m2021.03.15 23:08:48 INFO  time: compiled root in 0.14s[0m
[0m2021.03.15 23:09:23 INFO  compiling root (2 scala sources)[0m
[0m2021.03.15 23:09:23 INFO  time: compiled root in 0.9s[0m
[0m2021.03.15 23:10:40 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:10:40 INFO  time: compiled root in 0.7s[0m
[0m2021.03.15 23:16:36 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:16:36 INFO  time: compiled root in 0.68s[0m
Mar 15, 2021 11:17:45 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 15, 2021 11:17:46 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

[0m2021.03.15 23:20:28 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:20:28 INFO  time: compiled root in 0.12s[0m
[0m2021.03.15 23:21:21 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.15 23:21:21 INFO  time: compiled root in 0.24s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import java.io._
import java.nio.charset.StandardCharsets._
import java.nio.charset._
import java.nio.file.Files
import java.util.Locale

import javax.inject.Inject
import akka.actor.ActorSystem
import akka.stream._
import akka.stream.scaladsl.Flow
import akka.stream.scaladsl.Sink
import akka.stream.scaladsl.StreamConverters
import akka.stream.stage._
import akka.util.ByteString
import play.api._
import play.api.data.DefaultFormBinding
import play.api.data.Form
import play.api.data.FormBinding
import play.api.http.Status._
import play.api.http._
import play.api.libs.Files.SingletonTemporaryFileCreator
import play.api.libs.Files.TemporaryFile
import play.api.libs.Files.TemporaryFileCreator
import play.api.libs.json._
import play.api.libs.streams.Accumulator
import play.api.mvc.MultipartFormData._
import play.core.Execution
import play.core.parsers.Multipart
import play.utils.PlayIO

import scala.concurrent.ExecutionContext
import scala.concurrent.Future
import scala.concurrent.Promise
import scala.util.Failure
import scala.util.Success
import scala.util.Try
import scala.util.control.Exception.catching
import scala.util.control.NonFatal
import scala.xml._

/**
 * A request body that adapts automatically according the request Content-Type.
 */
sealed trait AnyContent {

  /**
   * application/x-www-form-urlencoded
   */
  def asFormUrlEncoded: Option[Map[String, Seq[String]]] = this match {
    case AnyContentAsFormUrlEncoded(data) => Some(data)
    case _                                => None
  }

  /**
   * text/plain
   */
  def asText: Option[String] = this match {
    case AnyContentAsText(txt) => Some(txt)
    case _                     => None
  }

  /**
   * application/xml
   */
  def asXml: Option[NodeSeq] = this match {
    case AnyContentAsXml(xml) => Some(xml)
    case _                    => None
  }

  /**
   * text/json or application/json
   */
  def asJson: Option[JsValue] = this match {
    case AnyContentAsJson(json) => Some(json)
    case _                      => None
  }

  /**
   * multipart/form-data
   */
  def asMultipartFormData: Option[MultipartFormData[TemporaryFile]] = this match {
    case AnyContentAsMultipartFormData(mfd) => Some(mfd)
    case _                                  => None
  }

  /**
   * Used when no Content-Type matches
   */
  def asRaw: Option[RawBuffer] = this match {
    case AnyContentAsRaw(raw) => Some(raw)
    case _                    => None
  }
}

/**
 * Factory object for creating an AnyContent instance.  Useful for unit testing.
 */
object AnyContent {
  def apply(): AnyContent                                           = AnyContentAsEmpty
  def apply(contentText: String): AnyContent                        = AnyContentAsText(contentText)
  def apply(json: JsValue): AnyContent                              = AnyContentAsJson(json)
  def apply(xml: NodeSeq): AnyContent                               = AnyContentAsXml(xml)
  def apply(formUrlEncoded: Map[String, Seq[String]]): AnyContent   = AnyContentAsFormUrlEncoded(formUrlEncoded)
  def apply(formData: MultipartFormData[TemporaryFile]): AnyContent = AnyContentAsMultipartFormData(formData)
  def apply(raw: RawBuffer): AnyContent                             = AnyContentAsRaw(raw)
}

/**
 * AnyContent - Empty request body
 */
case object AnyContentAsEmpty extends AnyContent

/**
 * AnyContent - Text body
 */
case class AnyContentAsText(txt: String) extends AnyContent

/**
 * AnyContent - Form url encoded body
 */
case class AnyContentAsFormUrlEncoded(data: Map[String, Seq[String]]) extends AnyContent

/**
 * AnyContent - Raw body (give access to the raw data as bytes).
 */
case class AnyContentAsRaw(raw: RawBuffer) extends AnyContent

/**
 * AnyContent - XML body
 */
case class AnyContentAsXml(xml: NodeSeq) extends AnyContent

/**
 * AnyContent - Json body
 */
case class AnyContentAsJson(json: JsValue) extends AnyContent

/**
 * AnyContent - Multipart form data body
 */
case class AnyContentAsMultipartFormData(mfd: MultipartFormData[TemporaryFile]) extends AnyContent

/**
 * Multipart form data body.
 */
case class MultipartFormData[A](dataParts: Map[String, Seq[String]], files: Seq[FilePart[A]], badParts: Seq[BadPart]) {

  /**
   * Extract the data parts as Form url encoded.
   */
  def asFormUrlEncoded: Map[String, Seq[String]] = dataParts

  /**
   * Access a file part.
   */
  def file(key: String): Option[FilePart[A]] = files.find(_.key == key)
}

/**
 * Defines parts handled by Multipart form data.
 */
object MultipartFormData {

  /**
   * A part.
   *
   * @tparam A the type that file parts are exposed as.
   */
  sealed trait Part[+A]

  /**
   * A data part.
   */
  case class DataPart(key: String, value: String) extends Part[Nothing]

  /**
   * A file part.
   */
  case class FilePart[A](
      key: String,
      filename: String,
      contentType: Option[String],
      ref: A,
      fileSize: Long = -1,
      dispositionType: String = "form-data"
  ) extends Part[A]

  /**
   * A part that has not been properly parsed.
   */
  case class BadPart(headers: Map[String, String]) extends Part[Nothing]

  /**
   * Emitted when the multipart stream can't be parsed for some reason.
   */
  case class ParseError(message: String) extends Part[Nothing]

  /**
   * The multipart/form-data parser buffers many things in memory, including data parts, headers, file names etc.
   *
   * Some buffer limits apply to each element, eg, there is a buffer for headers before they are parsed.  Other buffer
   * limits apply to all in memory data in aggregate, this includes data parts, file names, part names.
   *
   * If any of these buffers are exceeded, this will be emitted.
   */
  case class MaxMemoryBufferExceeded(message: String) extends Part[Nothing]
}

/**
 * Handle the request body a raw bytes data.
 *
 * @param memoryThreshold If the content size is bigger than this limit, the content is stored as file.
 * @param temporaryFileCreator the temporary file creator to store the content as file.
 * @param initialData the initial data, ByteString.empty by default.
 */
case class RawBuffer(
    memoryThreshold: Long,
    temporaryFileCreator: TemporaryFileCreator,
    initialData: ByteString = ByteString.empty
) {
  import play.api.libs.Files._

  @volatile private var inMemory: ByteString                 = initialData
  @volatile private var backedByTemporaryFile: TemporaryFile = _
  @volatile private var outStream: OutputStream              = _

  private[play] def push(chunk: ByteString): Unit = {
    if (inMemory != null) {
      if (chunk.length + inMemory.size > memoryThreshold) {
        backToTemporaryFile()
        outStream.write(chunk.toArray)
      } else {
        inMemory = inMemory ++ chunk
      }
    } else {
      outStream.write(chunk.toArray)
    }
  }

  private[play] def close(): Unit = if (outStream != null) outStream.close()

  private[play] def backToTemporaryFile(): Unit = {
    backedByTemporaryFile = temporaryFileCreator.create("requestBody", "asRaw")
    outStream = Files.newOutputStream(backedByTemporaryFile)
    outStream.write(inMemory.toArray)
    inMemory = null
  }

  /**
   * Buffer size.
   */
  def size: Long = {
    if (inMemory != null) inMemory.size else Files.size(backedByTemporaryFile)
  }

  /**
   * Returns the buffer content as a bytes array.
   *
   * This operation will cause the internal collection of byte arrays to be copied into a new byte array on each
   * invocation, no caching is done.  If the buffer has been written out to a file, it will read the contents of the
   * file.
   *
   * @param maxLength The max length allowed to be stored in memory.  If this is smaller than memoryThreshold, and the
   *                  buffer is already in memory then None will still be returned.
   * @return None if the content is greater than maxLength, otherwise, the data as bytes.
   */
  def asBytes(maxLength: Long = memoryThreshold): Option[ByteString] = {
    if (size <= maxLength) {
      Some(if (inMemory != null) inMemory else ByteString(PlayIO.readFile(backedByTemporaryFile.path)))
    } else {
      None
    }
  }

  /**
   * Returns the buffer content as File.
   */
  def asFile: File = {
    if (inMemory != null) {
      backToTemporaryFile()
      close()
    }
    backedByTemporaryFile
  }

  override def toString = {
    val inMemorySize: Any = Option(this.inMemory).map(_.size).orNull
    s"RawBuffer(inMemory=$inMemorySize, backedByTemporaryFile=$backedByTemporaryFile)"
  }
}

/**
 * A set of reusable body parsers and utilities that do not require configuration.
 */
trait BodyParserUtils {

  /**
   * Don't parse the body content.
   */
  def empty: BodyParser[Unit] = ignore(())

  def ignore[A](body: A): BodyParser[A] = BodyParser("ignore") { request =>
    Accumulator.done(Right(body))
  }

  /**
   * A body parser that always returns an error.
   */
  def error[A](result: Future[Result]): BodyParser[A] =
    BodyParser("error")(_ => Accumulator.done(result.map(Left.apply)(Execution.trampoline)))

  /**
   * Allows to choose the right BodyParser parser to use by examining the request headers.
   */
  def using[A](f: RequestHeader => BodyParser[A]) = BodyParser(request => f(request)(request))

  /**
   * A body parser that flattens a future BodyParser.
   */
  def flatten[A](underlying: Future[BodyParser[A]])(implicit ec: ExecutionContext, mat: Materializer): BodyParser[A] =
    BodyParser(request => Accumulator.flatten(underlying.map(_(request))))

  /**
   * Creates a conditional BodyParser.
   */
  def when[A](
      predicate: RequestHeader => Boolean,
      parser: BodyParser[A],
      badResult: RequestHeader => Future[Result]
  ): BodyParser[A] = {
    BodyParser(s"conditional, wrapping=$parser") { request =>
      if (predicate(request)) {
        parser(request)
      } else {
        Accumulator.done(badResult(request).map(Left.apply)(Execution.trampoline))
      }
    }
  }

  /**
   * Wrap an existing BodyParser with a maxLength constraints.
   *
   * @param maxLength The max length allowed
   * @param parser The BodyParser to wrap
   */
  def maxLength[A](maxLength: Long, parser: BodyParser[A])(
      implicit mat: Materializer
  ): BodyParser[Either[MaxSizeExceeded, A]] =
    BodyParser(s"maxLength=$maxLength, wrapping=$parser") { request =>
      if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
        Accumulator.done(Future.successful(Right(Left(MaxSizeExceeded(maxLength)))))
      } else {
        val takeUpToFlow = Flow.fromGraph(new BodyParsers.TakeUpTo(maxLength))

        // Apply the request
        val parserSink = parser.apply(request).toSink

        Accumulator(takeUpToFlow.toMat(parserSink) { (statusFuture, resultFuture) =>
          import Execution.Implicits.trampoline
          statusFuture.flatMap {
            case exceeded: MaxSizeExceeded => Future.successful(Right(Left(exceeded)))
            case _ =>
              resultFuture.map {
                case Left(result) => Left(result)
                case Right(a)     => Right(Right(a))
              }
          }
        })
      }
    }
}

object BodyParserUtils {

  /**
   * @param request The request whose Content-Length header will be checked (if it exists).
   * @param maxLength Maximum allowed bytes.
   * @return true if the request's Content-Length header value is greater than maxLength.
   *         false otherwise or if the request does not have a Content-Length header (or if it can't be parsed).
   */
  def contentLengthHeaderExceedsMaxLength(request: RequestHeader, maxLength: Long) =
    request.headers
      .get(HeaderNames.CONTENT_LENGTH)
      .flatMap(clh => catching(classOf[NumberFormatException]).opt(clh.toLong))
      .exists(_ > maxLength)
}

class DefaultPlayBodyParsers @Inject() (
    val config: ParserConfiguration,
    val errorHandler: HttpErrorHandler,
    val materializer: Materializer,
    val temporaryFileCreator: TemporaryFileCreator
) extends PlayBodyParsers

object PlayBodyParsers {

  /**
   * A helper method for creating PlayBodyParsers. The default values are mainly useful in testing, and default the
   * TemporaryFileCreator and HttpErrorHandler to singleton versions.
   */
  def apply(
      tfc: TemporaryFileCreator = SingletonTemporaryFileCreator,
      eh: HttpErrorHandler = new DefaultHttpErrorHandler(),
      conf: ParserConfiguration = ParserConfiguration()
  )(implicit mat: Materializer): PlayBodyParsers = {
    new DefaultPlayBodyParsers(conf, eh, mat, tfc)
  }
}

/**
 * Body parsers officially supported by Play (i.e. built-in to Play)
 */
trait PlayBodyParsers extends BodyParserUtils {
  private val logger = Logger(classOf[PlayBodyParsers])

  private[play] implicit def materializer: Materializer
  private[play] def config: ParserConfiguration
  private[play] def errorHandler: HttpErrorHandler
  private[play] def temporaryFileCreator: TemporaryFileCreator

  /**
   * Unlimited size.
   */
  val UNLIMITED: Long = Long.MaxValue

  private[play] val ApplicationXmlMatcher = """application/.*\+xml.*""".r

  /**
   * Default max length allowed for text based body.
   *
   * You can configure it in application.conf:
   *
   * {{{
   * play.http.parser.maxMemoryBuffer = 100k
   * }}}
   */
  def DefaultMaxTextLength: Long = config.maxMemoryBuffer

  /**
   * Default max length allowed for disk based body.
   *
   * You can configure it in application.conf:
   *
   * {{{
   * play.http.parser.maxDiskBuffer = 512k
   * }}}
   */
  def DefaultMaxDiskLength: Long = config.maxDiskBuffer

  /**
   * If empty file uploads are allowed (no matter if filename or file is empty)
   */
  def DefaultAllowEmptyFileUploads: Boolean = false

  // -- General purpose

  def formBinding(maxChars: Long = DefaultMaxTextLength): FormBinding = new DefaultFormBinding(maxChars)

  // -- Text parser

  /**
   * Parses the body as text without checking the Content-Type.
   *
   * Will attempt to parse content with an explicit charset, but will fallback to UTF-8, ISO-8859-1, and finally US-ASCII if incorrect characters are detected.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantText(maxLength: Long): BodyParser[String] =
    tolerantBodyParser("text", maxLength, "Error decoding text body") { (request, bytes) =>
      val byteBuffer = bytes.toByteBuffer

      def decode(encodingToTry: Charset): Try[String] = {
        import java.nio.charset.CodingErrorAction
        val decoder = encodingToTry.newDecoder.onMalformedInput(CodingErrorAction.REPORT)
        try {
          // Make sure we are at the beginning of the buffer - previous decoding attempts may have
          // managed to advance through a part of the buffer before failing.
          byteBuffer.rewind()
          Success(decoder.decode(byteBuffer).toString)
        } catch {
          case e: CharacterCodingException =>
            logger.warn(
              s"TolerantText body parser tried to parse request ${request.id} as text body with charset $encodingToTry, but it contains invalid characters!"
            )
            Failure(e)
          case e: Exception =>
            logger.error("Unexpected exception while decoding text/plain body", e)
            Failure(e)
        }
      }

      // Run through a common set of encoders to get an idea of the best character encoding.

      // Per RFC-7321, "The default charset of ISO-8859-1 for text media types has been removed; the default is now
      // whatever the media type definition says." and
      // The default "charset" parameter value for "text/plain" is unchanged from [RFC2046] and remains as "US-ASCII".
      // https://tools.ietf.org/html/rfc6657#section-4
      val charset = request.charset.fold(US_ASCII)(Charset.forName)
      decode(charset)
        .recoverWith {
          case _: CharacterCodingException => decode(UTF_8)
        }
        .recoverWith {
          case _: CharacterCodingException => decode(ISO_8859_1)
        }
        .getOrElse {
          // We can't get a decent charset.  If we added https://github.com/albfernandez/juniversalchardet
          // then we could guess at the encoding, but that's best done in userspace rather than adding
          // it into the core...
          bytes.decodeString(charset)
        }
    }

  /**
   * Parse the body as text without checking the Content-Type.
   */
  def tolerantText: BodyParser[String] = tolerantText(DefaultMaxTextLength)

  /**
   * Parse the body as text if the Content-Type is text/plain.
   *
   * If the charset is not explicitly declared, then the default "charset" parameter value is US-ASCII,
   * per https://tools.ietf.org/html/rfc6657#section-4.  Use tolerantText if more flexible character
   * decoding is desired.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def text(maxLength: Long): BodyParser[String] = {
    BodyParser("text") { request =>
      if (request.contentType.exists(_.equalsIgnoreCase("text/plain"))) {
        val bodyParser = tolerantBodyParser("text", maxLength, "Error decoding text body") { (request, bytes) =>
          val charset = request.charset.fold(US_ASCII)(Charset.forName)
          import java.nio.charset.CodingErrorAction
          val decoder = charset.newDecoder.onMalformedInput(CodingErrorAction.REPORT)
          try {
            // Render with assumption that all characters are valid
            decoder.decode(bytes.toByteBuffer).toString
          } catch {
            case e: CharacterCodingException =>
              // Log a warning, and render to the given charset with unmappable characters.
              // This is slower (exception + 2 * rendering) but the happy path is just as fast.
              logger.warn(
                s"Text body parser tried to parse request ${request.id} as text body with charset $charset, but it contains invalid characters!"
              )
              bytes.decodeString(charset)
          }
        }
        bodyParser(request)
      } else {
        Accumulator.done {
          val badResult = createBadResult("Expecting text/plain body", UNSUPPORTED_MEDIA_TYPE)
          badResult(request).map(Left.apply)(Execution.trampoline)
        }
      }
    }
  }

  /**
   * Parse the body as text if the Content-Type is text/plain.
   */
  def text: BodyParser[String] = text(DefaultMaxTextLength)

  /**
   * Buffer the body as a simple [[akka.util.ByteString]].
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def byteString(maxLength: Long): BodyParser[ByteString] = {
    tolerantBodyParser("byteString", maxLength, "Error decoding byte string body")((_, bytes) => bytes)
  }

  /**
   * Buffer the body as a simple [[akka.util.ByteString]].
   *
   * Will buffer up to the configured max memory buffer amount, after which point, it will return an EntityTooLarge
   * HTTP response.
   */
  def byteString: BodyParser[ByteString] = byteString(config.maxMemoryBuffer)

  // -- Raw parser

  /**
   * Store the body content in a RawBuffer.
   *
   * @param memoryThreshold If the content size is bigger than this limit, the content is stored as file.
   *
   * @see [[DefaultMaxDiskLength]]
   * @see [[Results.EntityTooLarge]]
   */
  def raw(memoryThreshold: Long = DefaultMaxTextLength, maxLength: Long = DefaultMaxDiskLength): BodyParser[RawBuffer] =
    BodyParser("raw, memoryThreshold=" + memoryThreshold) { request =>
      import Execution.Implicits.trampoline
      enforceMaxLength(
        request,
        maxLength,
        Accumulator
          .strict[ByteString, RawBuffer](
            { maybeStrictBytes =>
              Future.successful(
                RawBuffer(memoryThreshold, temporaryFileCreator, maybeStrictBytes.getOrElse(ByteString.empty))
              )
            }, {
              val buffer = RawBuffer(memoryThreshold, temporaryFileCreator)
              val sink = Sink.fold[RawBuffer, ByteString](buffer) { (bf, bs) =>
                bf.push(bs); bf
              }
              sink.mapMaterializedValue { future =>
                future.andThen { case _ => buffer.close() }
              }
            }
          )
          .map(buffer => Right(buffer))
      )
    }

  /**
   * Store the body content in a RawBuffer.
   */
  def raw: BodyParser[RawBuffer] = raw()

  // -- JSON parser

  /**
   * Parse the body as Json without checking the Content-Type.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantJson(maxLength: Long): BodyParser[JsValue] =
    tolerantBodyParser[JsValue]("json", maxLength, "Invalid Json") { (request, bytes) =>
      // Encoding notes: RFC 4627 requires that JSON be encoded in Unicode, and states that whether that's
      // UTF-8, UTF-16 or UTF-32 can be auto detected by reading the first two bytes. So we ignore the declared
      // charset and don't decode, we passing the byte array as is because Jackson supports auto detection.
      Json.parse(bytes.iterator.asInputStream)
    }

  /**
   * Parse the body as Json without checking the Content-Type.
   */
  def tolerantJson: BodyParser[JsValue] = tolerantJson(DefaultMaxTextLength)

  /**
   * Parse the body as Json without checking the Content-Type,
   * validating the result with the Json reader.
   *
   * @tparam A the type to read and validate from the body.
   * @param reader a Json reader for type A.
   */
  def tolerantJson[A](implicit reader: Reads[A]): BodyParser[A] = jsonReads(tolerantJson)

  /**
   * Parse the body as Json if the Content-Type is text/json or application/json.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def json(maxLength: Long): BodyParser[JsValue] = when(
    _.contentType.exists(m => m.equalsIgnoreCase("text/json") || m.equalsIgnoreCase("application/json")),
    tolerantJson(maxLength),
    createBadResult("Expecting text/json or application/json body", UNSUPPORTED_MEDIA_TYPE)
  )

  /**
   * Parse the body as Json if the Content-Type is text/json or application/json.
   */
  def json: BodyParser[JsValue] = json(DefaultMaxTextLength)

  /**
   * Parse the body as Json if the Content-Type is text/json or application/json,
   * validating the result with the Json reader.
   *
   * @tparam A the type to read and validate from the body.
   * @param reader a Json reader for type A.
   */
  def json[A](implicit reader: Reads[A]): BodyParser[A] = jsonReads(json)

  /**
   * Parse the body as Json given a BodyParser,
   * validating the result with the Json reader.
   */
  private def jsonReads[A](parser: BodyParser[JsValue])(implicit reader: Reads[A]): BodyParser[A] =
    BodyParser("json reader") { request =>
      import Execution.Implicits.trampoline
      parser(request).mapFuture {
        case Left(simpleResult) =>
          Future.successful(Left(simpleResult))
        case Right(jsValue) =>
          jsValue
            .validate(reader)
            .map { a =>
              Future.successful(Right(a))
            }
            .recoverTotal { jsError =>
              val msg = s"Json validation error ${JsError.toFlatForm(jsError)}"
              createBadResult(msg)(request).map(Left.apply)
            }
      }
    }

  // -- Form parser

  /**
   * Parse the body and binds it to a given form model.
   *
   * {{{
   *   case class User(name: String)
   *
   *   val userForm: Form[User] = Form(mapping("name" -> nonEmptyText)(User.apply)(User.unapply))
   *
   *   Action(parse.form(userForm)) { request =>
   *     Ok(s"Hello, \${request.body.name}!")
   *   }
   * }}}
   *
   * @param form Form model
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response. If `None`, the default `play.http.parser.maxMemoryBuffer` configuration value is used.
   * @param onErrors The result to reply in case of errors during the form binding process
   */
  def form[A](
      form: Form[A],
      maxLength: Option[Long] = None,
      onErrors: Form[A] => Result = (_: Form[A]) => Results.BadRequest
  ): BodyParser[A] =
    BodyParser { requestHeader =>
      val parser  = anyContent(maxLength)
      val binding = formBinding(maxLength.getOrElse(DefaultMaxTextLength))
      parser(requestHeader).map { resultOrBody =>
        resultOrBody.right.flatMap { body =>
          form
            .bindFromRequest()(Request[AnyContent](requestHeader, body), binding)
            .fold(formErrors => Left(onErrors(formErrors)), a => Right(a))
        }
      }(Execution.trampoline)
    }

  // -- XML parser

  /**
   * Parse the body as Xml without checking the Content-Type.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantXml(maxLength: Long): BodyParser[NodeSeq] =
    tolerantBodyParser[NodeSeq]("xml", maxLength, "Invalid XML") { (request, bytes) =>
      val inputSource = new InputSource(bytes.iterator.asInputStream)

      // Encoding notes: RFC 3023 is the RFC for XML content types.  Comments below reflect what it says.

      // An externally declared charset takes precedence
      request.charset
        .orElse(
          // If omitted, maybe select a default charset, based on the media type.
          request.mediaType.collect {
            // According to RFC 3023, the default encoding for text/xml is us-ascii. This contradicts RFC 2616, which
            // states that the default for text/* is ISO-8859-1.  An RFC 3023 conforming client will send US-ASCII,
            // in that case it is safe for us to use US-ASCII or ISO-8859-1.  But a client that knows nothing about
            // XML, and therefore nothing about RFC 3023, but rather conforms to RFC 2616, will send ISO-8859-1.
            // Since decoding as ISO-8859-1 works for both clients that conform to RFC 3023, and clients that conform
            // to RFC 2616, we use that.
            case mt if mt.mediaType == "text" => "iso-8859-1"
            // Otherwise, there should be no default, it will be detected by the XML parser.
          }
        )
        .foreach { charset =>
          inputSource.setEncoding(charset)
        }
      Play.XML.load(inputSource)
    }

  /**
   * Parse the body as Xml without checking the Content-Type.
   */
  def tolerantXml: BodyParser[NodeSeq] = tolerantXml(DefaultMaxTextLength)

  /**
   * Parse the body as Xml if the Content-Type is application/xml, text/xml or application/XXX+xml.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def xml(maxLength: Long): BodyParser[NodeSeq] = when(
    _.contentType.exists { t =>
      val tl = t.toLowerCase(Locale.ENGLISH)
      tl.startsWith("text/xml") || tl
        .startsWith("application/xml") || ApplicationXmlMatcher.pattern.matcher(tl).matches()
    },
    tolerantXml(maxLength),
    createBadResult("Expecting xml body", UNSUPPORTED_MEDIA_TYPE)
  )

  /**
   * Parse the body as Xml if the Content-Type is application/xml, text/xml or application/XXX+xml.
   */
  def xml: BodyParser[NodeSeq] = xml(DefaultMaxTextLength)

  // -- File parsers

  /**
   * Store the body content into a file.
   *
   * @param to The file used to store the content.
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def file(to: File, maxLength: Long): BodyParser[File] = BodyParser(s"file, to=$to") { request =>
    import Execution.Implicits.trampoline
    val bodyAccumulator =
      Accumulator(StreamConverters.fromOutputStream(() => Files.newOutputStream(to.toPath))).map(_ => Right(to))
    enforceMaxLength(request, maxLength, bodyAccumulator)
  }

  /**
   * Store the body content into a file.
   *
   * @param to The file used to store the content.
   */
  def file(to: File): BodyParser[File] = file(to, DefaultMaxDiskLength)

  private def requestEntityTooLarge(request: RequestHeader) =
    createBadResult("Request Entity Too Large", REQUEST_ENTITY_TOO_LARGE)(request).map(Left(_))(Execution.trampoline)

  /**
   * Store the body content into a temporary file.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def temporaryFile(maxLength: Long): BodyParser[TemporaryFile] = BodyParser("temporaryFile") { request =>
    if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
      // We check early here already to not even create a temporary file
      Accumulator.done(requestEntityTooLarge(request))
    } else {
      val tempFile = temporaryFileCreator.create("requestBody", "asTemporaryFile")
      file(tempFile, maxLength)(request).map(_.fold(result => Left(result), _ => Right(tempFile)))(Execution.trampoline)
    }
  }

  /**
   * Store the body content into a temporary file.
   */
  def temporaryFile: BodyParser[TemporaryFile] = temporaryFile(DefaultMaxDiskLength)

  // -- FormUrlEncoded

  /**
   * Parse the body as Form url encoded without checking the Content-Type.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def tolerantFormUrlEncoded(maxLength: Long): BodyParser[Map[String, Seq[String]]] =
    tolerantBodyParser("formUrlEncoded", maxLength, "Error parsing application/x-www-form-urlencoded") {
      (request, bytes) =>
        import play.core.parsers._
        val charset          = request.charset.getOrElse("UTF-8")
        val urlEncodedString = bytes.decodeString("UTF-8")
        FormUrlEncodedParser.parse(urlEncodedString, charset)
    }

  /**
   * Parse the body as form url encoded without checking the Content-Type.
   */
  def tolerantFormUrlEncoded: BodyParser[Map[String, Seq[String]]] =
    tolerantFormUrlEncoded(DefaultMaxTextLength)

  /**
   * Parse the body as form url encoded if the Content-Type is application/x-www-form-urlencoded.
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def formUrlEncoded(maxLength: Long): BodyParser[Map[String, Seq[String]]] = when(
    _.contentType.exists(_.equalsIgnoreCase("application/x-www-form-urlencoded")),
    tolerantFormUrlEncoded(maxLength),
    createBadResult("Expecting application/x-www-form-urlencoded body", UNSUPPORTED_MEDIA_TYPE)
  )

  /**
   * Parse the body as form url encoded if the Content-Type is application/x-www-form-urlencoded.
   */
  def formUrlEncoded: BodyParser[Map[String, Seq[String]]] =
    formUrlEncoded(DefaultMaxTextLength)

  // -- Magic any content

  /**
   * If the request has a body, parse the body content by checking the Content-Type header.
   */
  def default: BodyParser[AnyContent] = default(None)

  // this is an alias method since "default" is a Java reserved word
  def defaultBodyParser: BodyParser[AnyContent] = default

  /**
   * If the request has a body, parse the body content by checking the Content-Type header.
   */
  def default(maxLength: Option[Long]): BodyParser[AnyContent] = using { request =>
    if (request.hasBody) {
      anyContent(maxLength)
    } else {
      ignore(AnyContentAsEmpty)
    }
  }

  /**
   * Guess the body content by checking the Content-Type header.
   */
  def anyContent: BodyParser[AnyContent] = anyContent(None)

  /**
   * Guess the body content by checking the Content-Type header.
   */
  def anyContent(maxLength: Option[Long]): BodyParser[AnyContent] = BodyParser("anyContent") { request =>
    import Execution.Implicits.trampoline

    def maxLengthOrDefault          = maxLength.fold(DefaultMaxTextLength)(_.toInt)
    def maxLengthOrDefaultLarge     = maxLength.getOrElse(DefaultMaxDiskLength)
    val contentType: Option[String] = request.contentType.map(_.toLowerCase(Locale.ENGLISH))
    contentType match {
      case Some("text/plain") =>
        logger.trace("Parsing AnyContent as text")
        text(maxLengthOrDefault)(request).map(_.right.map(s => AnyContentAsText(s)))

      case Some("text/xml") | Some("application/xml") | Some(ApplicationXmlMatcher()) =>
        logger.trace("Parsing AnyContent as xml")
        xml(maxLengthOrDefault)(request).map(_.right.map(x => AnyContentAsXml(x)))

      case Some("text/json") | Some("application/json") =>
        logger.trace("Parsing AnyContent as json")
        json(maxLengthOrDefault)(request).map(_.right.map(j => AnyContentAsJson(j)))

      case Some("application/x-www-form-urlencoded") =>
        logger.trace("Parsing AnyContent as urlFormEncoded")
        formUrlEncoded(maxLengthOrDefault)(request).map(_.right.map(d => AnyContentAsFormUrlEncoded(d)))

      case Some("multipart/form-data") =>
        logger.trace("Parsing AnyContent as multipartFormData")
        multipartFormData(
          Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator),
          maxLengthOrDefaultLarge,
          DefaultAllowEmptyFileUploads
        ).apply(request)
          .map(_.right.map(m => AnyContentAsMultipartFormData(m)))

      case _ =>
        logger.trace("Parsing AnyContent as raw")
        raw(DefaultMaxTextLength, maxLengthOrDefaultLarge)(request).map(_.right.map(r => AnyContentAsRaw(r)))
    }
  }

  // -- Multipart

  /**
   * Parse the content as multipart/form-data
   */
  def multipartFormData: BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator))

  /**
   * Parse the content as multipart/form-data
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   */
  def multipartFormData(maxLength: Long): BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), maxLength)

  /**
   * Parse the content as multipart/form-data
   *
   * @param allowEmptyFiles If empty file uploads are allowed (no matter if filename or file is empty)
   */
  def multipartFormData(allowEmptyFiles: Boolean): BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), allowEmptyFiles = allowEmptyFiles)

  /**
   * Parse the content as multipart/form-data
   *
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   * @param allowEmptyFiles If empty file uploads are allowed (no matter if filename or file is empty)
   */
  def multipartFormData(maxLength: Long, allowEmptyFiles: Boolean): BodyParser[MultipartFormData[TemporaryFile]] =
    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), maxLength, allowEmptyFiles)

  /**
   * Parse the content as multipart/form-data
   *
   * @param filePartHandler Handles file parts.
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   *
   * @see [[DefaultMaxDiskLength]]
   * @see [[Results.EntityTooLarge]]
   */
  def multipartFormData[A](
      filePartHandler: Multipart.FilePartHandler[A],
      maxLength: Long
  ): BodyParser[MultipartFormData[A]] = multipartFormData(filePartHandler, maxLength, false)

  /**
   * Parse the content as multipart/form-data
   *
   * @param filePartHandler Handles file parts.
   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
   * @param allowEmptyFiles If empty file uploads are allowed (no matter if filename or file is empty)
   *
   * @see [[DefaultMaxDiskLength]]
   * @see [[Results.EntityTooLarge]]
   */
  def multipartFormData[A](
      filePartHandler: Multipart.FilePartHandler[A],
      maxLength: Long = DefaultMaxDiskLength,
      allowEmptyFiles: Boolean = DefaultAllowEmptyFileUploads
  ): BodyParser[MultipartFormData[A]] = {
    BodyParser("multipartFormData") { request =>
      val bodyAccumulator =
        Multipart.multipartParser(DefaultMaxTextLength, allowEmptyFiles, filePartHandler, errorHandler).apply(request)
      enforceMaxLength(request, maxLength, bodyAccumulator)
    }
  }

  protected def createBadResult(msg: String, statusCode: Int = BAD_REQUEST): RequestHeader => Future[Result] = {
    request =>
      errorHandler.onClientError(request, statusCode, msg)
  }

  /**
   * Enforce the max length on the stream consumed by the given accumulator.
   */
  private[play] def enforceMaxLength[A](
      request: RequestHeader,
      maxLength: Long,
      accumulator: Accumulator[ByteString, Either[Result, A]]
  ): Accumulator[ByteString, Either[Result, A]] = {
    if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
      Accumulator.done(requestEntityTooLarge(request))
    } else {
      val takeUpToFlow = Flow.fromGraph(new BodyParsers.TakeUpTo(maxLength))
      Accumulator(takeUpToFlow.toMat(accumulator.toSink) { (statusFuture, resultFuture) =>
        statusFuture.flatMap {
          case MaxSizeExceeded(_) => requestEntityTooLarge(request)
          case MaxSizeNotExceeded => resultFuture
        }(Execution.trampoline)
      })
    }
  }

  /**
   * Create a body parser that uses the given parser and enforces the given max length.
   *
   * @param name The name of the body parser.
   * @param maxLength The maximum length of the body to buffer.
   * @param errorMessage The error message to prepend to the exception message if an error was encountered.
   * @param parser The parser.
   */
  protected def tolerantBodyParser[A](name: String, maxLength: Long, errorMessage: String)(
      parser: (RequestHeader, ByteString) => A
  ): BodyParser[A] =
    BodyParser(name + ", maxLength=" + maxLength) { request =>
      import Execution.Implicits.trampoline

      def parseBody(bytes: ByteString): Future[Either[Result, A]] = {
        try {
          Future.successful(Right(parser(request, bytes)))
        } catch {
          case NonFatal(e) =>
            logger.debug(errorMessage, e)
            createBadResult(errorMessage + ": " + e.getMessage)(request).map(Left(_))
        }
      }

      if (BodyParserUtils.contentLengthHeaderExceedsMaxLength(request, maxLength)) {
        Accumulator.done(requestEntityTooLarge(request))
      } else {
        Accumulator.strict[ByteString, Either[Result, A]](
          // If the body was strict
          {
            case Some(bytes) if bytes.size <= maxLength =>
              parseBody(bytes)
            case None =>
              parseBody(ByteString.empty)
            case _ => requestEntityTooLarge(request)
          },
          // Otherwise, use an enforce max length accumulator on a folding sink
          enforceMaxLength(
            request,
            maxLength,
            Accumulator(
              Sink.fold[ByteString, ByteString](ByteString.empty)((state, bs) => state ++ bs)
            ).mapFuture(parseBody)
          ).toSink
        )
      }
    }
}

/**
 * Default BodyParsers.
 */
object BodyParsers {

  /**
   * The default body parser provided by Play
   */
  class Default @Inject() (parse: PlayBodyParsers) extends BodyParser[AnyContent] {

    /**
     * An alternate constructor primarily designed for unit testing. Default values are set to empty or singleton
     * implementations where appropriate.
     */
    def this(
        tfc: TemporaryFileCreator = SingletonTemporaryFileCreator,
        eh: HttpErrorHandler = new DefaultHttpErrorHandler(),
        config: ParserConfiguration = ParserConfiguration()
    )(implicit mat: Materializer) = this(PlayBodyParsers(tfc, eh, config))
    override def apply(rh: RequestHeader) = parse.default(None)(rh)
  }

  object utils extends BodyParserUtils

  private[play] def takeUpTo(maxLength: Long): Graph[FlowShape[ByteString, ByteString], Future[MaxSizeStatus]] =
    new TakeUpTo(maxLength)

  private[play] class TakeUpTo(maxLength: Long)
      extends GraphStageWithMaterializedValue[FlowShape[ByteString, ByteString], Future[MaxSizeStatus]] {
    private val in  = Inlet[ByteString]("TakeUpTo.in")
    private val out = Outlet[ByteString]("TakeUpTo.out")

    override def shape: FlowShape[ByteString, ByteString] = FlowShape.of(in, out)

    override def createLogicAndMaterializedValue(
        inheritedAttributes: Attributes
    ): (GraphStageLogic, Future[MaxSizeStatus]) = {
      val status            = Promise[MaxSizeStatus]()
      var pushedBytes: Long = 0

      val logic = new GraphStageLogic(shape) {
        setHandler(out, new OutHandler {
          override def onPull(): Unit = {
            pull(in)
          }
          override def onDownstreamFinish(): Unit = {
            status.success(MaxSizeNotExceeded)
            completeStage()
          }
        })
        setHandler(
          in,
          new InHandler {
            override def onPush(): Unit = {
              val chunk = grab(in)
              pushedBytes += chunk.size
              if (pushedBytes > maxLength) {
                status.success(MaxSizeExceeded(maxLength))
                // Make sure we fail the stream, this will ensure downstream body parsers don't try to parse it
                failStage(new MaxLengthLimitAttained)
              } else {
                push(out, chunk)
              }
            }
            override def onUpstreamFinish(): Unit = {
              status.success(MaxSizeNotExceeded)
              completeStage()
            }
            override def onUpstreamFailure(ex: Throwable): Unit = {
              status.failure(ex)
              failStage(ex)
            }
          }
        )
      }

      (logic, status.future)
    }
  }

  private[play] class MaxLengthLimitAttained extends RuntimeException(null, null, false, false)
}

/**
 * The status of a max size flow.
 */
sealed trait MaxSizeStatus

/**
 * Signal a max content size exceeded.
 */
case class MaxSizeExceeded(length: Long) extends MaxSizeStatus

/**
 * Signal max size is not exceeded.
 */
case object MaxSizeNotExceeded extends MaxSizeStatus

[0m2021.03.15 23:21:26 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.15 23:21:28 INFO  time: compiled root in 1.65s[0m
Mar 15, 2021 11:24:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6859
[0m2021.03.15 23:24:42 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:24:42 INFO  time: compiled root in 0.72s[0m
[0m2021.03.15 23:28:19 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:28:19 INFO  time: compiled root in 0.76s[0m
[0m2021.03.15 23:31:29 INFO  compiling root (4 scala sources and 1 java source)[0m
[0m2021.03.15 23:31:30 WARN  unexpected error processing the file C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\target\scala-2.13\routes\main\controllers\javascript\JavaScriptReverseRoutes.scala.semanticdb
java.nio.file.FileSystemException: C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\target\scala-2.13\routes\main\controllers\javascript\JavaScriptReverseRoutes.scala.semanticdb: The process cannot access the file because it is being used by another process.

	at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:86)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)
	at sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:230)
	at java.nio.file.Files.newByteChannel(Files.java:361)
	at java.nio.file.Files.newByteChannel(Files.java:407)
	at java.nio.file.Files.readAllBytes(Files.java:3152)
	at scala.meta.internal.metals.SemanticdbIndexer.onChange(SemanticdbIndexer.scala:96)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChangeWatchedFiles$5(MetalsLanguageServer.scala:1220)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[0m
[0m2021.03.15 23:31:30 INFO  time: compiled root in 1.44s[0m
[0m2021.03.15 23:32:11 INFO  compiling root (4 scala sources and 1 java source)[0m
[0m2021.03.15 23:32:12 INFO  time: compiled root in 1.15s[0m
Mar 15, 2021 11:32:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7016
[0m2021.03.15 23:36:01 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:36:01 INFO  time: compiled root in 0.77s[0m
[0m2021.03.15 23:36:27 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:36:27 INFO  time: compiled root in 0.13s[0m
[0m2021.03.15 23:37:28 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:37:28 INFO  time: compiled root in 0.74s[0m
[0m2021.03.15 23:43:03 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:43:03 INFO  time: compiled root in 0.13s[0m
[0m2021.03.15 23:45:01 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:45:01 INFO  time: compiled root in 0.71s[0m
[0m2021.03.15 23:46:57 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.15 23:46:58 INFO  time: compiled root in 1.52s[0m
Mar 15, 2021 11:47:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7787
[0m2021.03.15 23:48:51 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:48:51 INFO  time: compiled root in 0.83s[0m
[0m2021.03.15 23:49:58 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:49:58 INFO  time: compiled root in 0.73s[0m
[0m2021.03.15 23:51:45 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:51:45 INFO  time: compiled root in 0.75s[0m
[0m2021.03.15 23:52:07 INFO  compiling root (1 scala source)[0m
[0m2021.03.15 23:52:07 INFO  time: compiled root in 0.76s[0m
[0m2021.03.15 23:58:57 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.15 23:58:57 INFO  time: compiled root in 0.28s[0m
[0m2021.03.16 00:02:04 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:02:06 INFO  time: compiled root in 1.56s[0m
[0m2021.03.16 00:02:29 INFO  compiling root (2 scala sources)[0m
[0m2021.03.16 00:02:29 INFO  time: compiled root in 0.7s[0m
[0m2021.03.16 00:02:29 INFO  compiling root (3 scala sources)[0m
[0m2021.03.16 00:02:30 WARN  unexpected error processing the file C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\target\scala-2.13\twirl\main\views\html\index.template.scala.semanticdb
java.nio.file.FileSystemException: C:\Users\Chet\WebApps\messageboard\.bloop\root\bloop-bsp-clients-classes\classes-Metals-ybnzvewyTgW73mNXHN6Qfg==\META-INF\semanticdb\target\scala-2.13\twirl\main\views\html\index.template.scala.semanticdb: The process cannot access the file because it is being used by another process.

	at sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:86)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:97)
	at sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:102)
	at sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:230)
	at java.nio.file.Files.newByteChannel(Files.java:361)
	at java.nio.file.Files.newByteChannel(Files.java:407)
	at java.nio.file.Files.readAllBytes(Files.java:3152)
	at scala.meta.internal.metals.SemanticdbIndexer.onChange(SemanticdbIndexer.scala:96)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChangeWatchedFiles$5(MetalsLanguageServer.scala:1220)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
[0m
[0m2021.03.16 00:02:30 INFO  time: compiled root in 0.38s[0m
[0m2021.03.16 00:03:14 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:03:14 INFO  time: compiled root in 0.65s[0m
[0m2021.03.16 00:03:26 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:03:26 INFO  time: compiled root in 0.61s[0m
[0m2021.03.16 00:04:57 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:04:57 INFO  time: compiled root in 0.69s[0m
Mar 16, 2021 12:06:39 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 16, 2021 12:06:39 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

Mar 16, 2021 12:13:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8561
Mar 16, 2021 12:13:38 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 16, 2021 12:13:38 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

[0m2021.03.16 00:14:23 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:14:23 INFO  time: compiled root in 0.66s[0m
[0m2021.03.16 00:15:59 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:15:59 INFO  time: compiled root in 0.13s[0m
[0m2021.03.16 00:16:05 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:16:05 INFO  time: compiled root in 0.12s[0m
[0m2021.03.16 00:16:30 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:16:30 INFO  time: compiled root in 0.17s[0m
[0m2021.03.16 00:17:32 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:17:32 INFO  time: compiled root in 0.13s[0m
[0m2021.03.16 00:18:37 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:18:37 INFO  time: compiled root in 0.81s[0m
Mar 16, 2021 12:20:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9202
[0m2021.03.16 00:20:26 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:20:26 INFO  time: compiled root in 0.6s[0m
[0m2021.03.16 00:23:30 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:23:30 INFO  time: compiled root in 95ms[0m
[0m2021.03.16 00:24:06 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:24:08 INFO  time: compiled root in 2.01s[0m
Mar 16, 2021 12:24:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9270
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala
package collection
package immutable

import generic._
import mutable.{Builder, ListBuffer}
import scala.annotation.tailrec
import java.io.{ObjectOutputStream, ObjectInputStream}

/** A class for immutable linked lists representing ordered collections
 *  of elements of type `A`.
 *
 *  This class comes with two implementing case classes `scala.Nil`
 *  and `scala.::` that implement the abstract members `isEmpty`,
 *  `head` and `tail`.
 *
 *  This class is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access
 *  pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.
 *
 *  $usesMutableState
 *
 *  ==Performance==
 *  '''Time:''' `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list.
 *  This includes the index-based lookup of elements, `length`, `append` and `reverse`.
 *
 *  '''Space:''' `List` implements '''structural sharing''' of the tail list. This means that many operations are either
 *  zero- or constant-memory cost.
 *  {{{
 *  val mainList = List(3, 2, 1)
 *  val with4 =    4 :: mainList  // re-uses mainList, costs one :: instance
 *  val with42 =   42 :: mainList // also re-uses mainList, cost one :: instance
 *  val shorter =  mainList.tail  // costs nothing as it uses the same 2::1::Nil instances as mainList
 *  }}}
 *
 *  @example {{{
 *  // Make a list via the companion object factory
 *  val days = List("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")
 *
 *  // Make a list element-by-element
 *  val when = "AM" :: "PM" :: List()
 *
 *  // Pattern match
 *  days match {
 *    case firstDay :: otherDays =>
 *      println("The first day of the week is: " + firstDay)
 *    case List() =>
 *      println("There don't seem to be any week days.")
 *  }
 *  }}}
 *
 *  @note The functional list is characterized by persistence and structural sharing, thus offering considerable
 *        performance and space consumption benefits in some scenarios if used correctly.
 *        However, note that objects having multiple references into the same functional list (that is,
 *        objects that rely on structural sharing), will be serialized and deserialized with multiple lists, one for
 *        each reference to it. I.e. structural sharing is lost after serialization/deserialization.
 *
 *  @author  Martin Odersky and others
 *  @since   1.0
 *  @see  [[http://docs.scala-lang.org/overviews/collections/concrete-immutable-collection-classes.html#lists "Scala's Collection Library overview"]]
 *  section on `Lists` for more information.
 *
 *  @define coll list
 *  @define Coll `List`
 *  @define thatinfo the class of the returned collection. In the standard library configuration,
 *    `That` is always `List[B]` because an implicit of type `CanBuildFrom[List, B, That]`
 *    is defined in object `List`.
 *  @define bfinfo an implicit value of class `CanBuildFrom` which determines the
 *    result class `That` from the current representation type `Repr`
 *    and the new element type `B`. This is usually the `canBuildFrom` value
 *    defined in object `List`.
 *  @define orderDependent
 *  @define orderDependentFold
 *  @define mayNotTerminateInf
 *  @define willNotTerminateInf
 */
@SerialVersionUID(-6084104484083858598L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
sealed abstract class List[+A] extends AbstractSeq[A]
                                  with LinearSeq[A]
                                  with Product
                                  with GenericTraversableTemplate[A, List]
                                  with LinearSeqOptimized[A, List[A]]
                                  with scala.Serializable {
  override def companion: GenericCompanion[List] = List

  def isEmpty: Boolean
  def head: A
  def tail: List[A]

  // New methods in List

  /** Adds an element at the beginning of this list.
   *  @param x the element to prepend.
   *  @return  a list which contains `x` as first element and
   *           which continues with this list.
   *
   *  @usecase def ::(x: A): List[A]
   *    @inheritdoc
   *
   *    Example:
   *    {{{1 :: List(2, 3) = List(2, 3).::(1) = List(1, 2, 3)}}}
   */
  def ::[B >: A] (x: B): List[B] =
    new scala.collection.immutable.::(x, this)

  /** Adds the elements of a given list in front of this list.
   *  @param prefix  The list elements to prepend.
   *  @return a list resulting from the concatenation of the given
   *    list `prefix` and this list.
   *
   *  @usecase def :::(prefix: List[A]): List[A]
   *    @inheritdoc
   *
   *    Example:
   *    {{{List(1, 2) ::: List(3, 4) = List(3, 4).:::(List(1, 2)) = List(1, 2, 3, 4)}}}
   */
  def :::[B >: A](prefix: List[B]): List[B] =
    if (isEmpty) prefix
    else if (prefix.isEmpty) this
    else (new ListBuffer[B] ++= prefix).prependToList(this)

  /** Adds the elements of a given list in reverse order in front of this list.
   *  `xs reverse_::: ys` is equivalent to
   *  `xs.reverse ::: ys` but is more efficient.
   *
   *  @param prefix the prefix to reverse and then prepend
   *  @return       the concatenation of the reversed prefix and the current list.
   *
   *  @usecase def reverse_:::(prefix: List[A]): List[A]
   *    @inheritdoc
   */
  def reverse_:::[B >: A](prefix: List[B]): List[B] = {
    var these: List[B] = this
    var pres = prefix
    while (!pres.isEmpty) {
      these = pres.head :: these
      pres = pres.tail
    }
    these
  }

  /** Builds a new list by applying a function to all elements of this list.
   *  Like `xs map f`, but returns `xs` unchanged if function
   *  `f` maps all elements to themselves (as determined by `eq`).
   *
   *  @param f      the function to apply to each element.
   *  @tparam B     the element type of the returned collection.
   *  @return       a list resulting from applying the given function
   *                `f` to each element of this list and collecting the results.
   *
   *  @usecase def mapConserve(f: A => A): List[A]
   *    @inheritdoc
   */
  @inline final def mapConserve[B >: A <: AnyRef](f: A => B): List[B] = {
    // Note to developers: there exists a duplication between this function and `reflect.internal.util.Collections#map2Conserve`.
    // If any successful optimization attempts or other changes are made, please rehash them there too.
    @tailrec
    def loop(mappedHead: List[B] = Nil, mappedLast: ::[B], unchanged: List[A], pending: List[A]): List[B] =
    if (pending.isEmpty) {
      if (mappedHead eq null) unchanged
      else {
        mappedLast.tl = unchanged
        mappedHead
      }
    }
    else {
      val head0 = pending.head
      val head1 = f(head0)

      if (head1 eq head0.asInstanceOf[AnyRef])
        loop(mappedHead, mappedLast, unchanged, pending.tail)
      else {
        var xc = unchanged
        var mappedHead1: List[B] = mappedHead
        var mappedLast1: ::[B] = mappedLast
        while (xc ne pending) {
          val next = new ::[B](xc.head, Nil)
          if (mappedHead1 eq null) mappedHead1 = next
          if (mappedLast1 ne null) mappedLast1.tl = next
          mappedLast1 = next
          xc = xc.tail
        }
        val next = new ::(head1, Nil)
        if (mappedHead1 eq null) mappedHead1 = next
        if (mappedLast1 ne null) mappedLast1.tl = next
        mappedLast1 = next
        val tail0 = pending.tail
        loop(mappedHead1, mappedLast1, tail0, tail0)

      }
    }
    loop(null, null, this, this)
  }

  // Overridden methods from IterableLike and SeqLike or overloaded variants of such methods

  override def ++[B >: A, That](that: GenTraversableOnce[B])(implicit bf: CanBuildFrom[List[A], B, That]): That =
    if (bf eq List.ReusableCBF) (this ::: that.seq.toList).asInstanceOf[That]
    else super.++(that)

  override def +:[B >: A, That](elem: B)(implicit bf: CanBuildFrom[List[A], B, That]): That = bf match {
    case _: List.GenericCanBuildFrom[_] => (elem :: this).asInstanceOf[That]
    case _ => super.+:(elem)(bf)
  }

  override def toList: List[A] = this

  override def take(n: Int): List[A] = if (isEmpty || n <= 0) Nil else {
    val h = new ::(head, Nil)
    var t = h
    var rest = tail
    var i = 1
    while ({if (rest.isEmpty) return this; i < n}) {
      i += 1
      val nx = new ::(rest.head, Nil)
      t.tl = nx
      t = nx
      rest = rest.tail
    }
    h
  }

  override def drop(n: Int): List[A] = {
    var these = this
    var count = n
    while (!these.isEmpty && count > 0) {
      these = these.tail
      count -= 1
    }
    these
  }

  /**
   *  @example {{{
   *  // Given a list
   *  val letters = List('a','b','c','d','e')
   *
   *  // `slice` returns all elements beginning at index `from` and afterwards,
   *  // up until index `until` (excluding index `until`.)
   *  letters.slice(1,3) // Returns List('b','c')
   *  }}}
   */
  override def slice(from: Int, until: Int): List[A] = {
    val lo = scala.math.max(from, 0)
    if (until <= lo || isEmpty) Nil
    else this drop lo take (until - lo)
  }

  override def takeRight(n: Int): List[A] = {
    @tailrec
    def loop(lead: List[A], lag: List[A]): List[A] = lead match {
      case Nil => lag
      case _ :: tail => loop(tail, lag.tail)
    }
    loop(drop(n), this)
  }

  // dropRight is inherited from LinearSeq

  override def splitAt(n: Int): (List[A], List[A]) = {
    val b = new ListBuffer[A]
    var i = 0
    var these = this
    while (!these.isEmpty && i < n) {
      i += 1
      b += these.head
      these = these.tail
    }
    (b.toList, these)
  }

  final override def map[B, That](f: A => B)(implicit bf: CanBuildFrom[List[A], B, That]): That = {
    if (bf eq List.ReusableCBF) {
      if (this eq Nil) Nil.asInstanceOf[That] else {
        val h = new ::[B](f(head), Nil)
        var t: ::[B] = h
        var rest = tail
        while (rest ne Nil) {
          val nx = new ::(f(rest.head), Nil)
          t.tl = nx
          t = nx
          rest = rest.tail
        }
        h.asInstanceOf[That]
      }
    }
    else super.map(f)
  }

  final override def collect[B, That](pf: PartialFunction[A, B])(implicit bf: CanBuildFrom[List[A], B, That]): That = {
    if (bf eq List.ReusableCBF) {
      if (this eq Nil) Nil.asInstanceOf[That] else {
        var rest = this
        var h: ::[B] = null
        // Special case for first element
        do {
          val x: Any = pf.applyOrElse(rest.head, List.partialNotApplied)
          if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) h = new ::(x.asInstanceOf[B], Nil)
          rest = rest.tail
          if (rest eq Nil) return (if (h eq null ) Nil else h).asInstanceOf[That]
        } while (h eq null)
        var t = h
        // Remaining elements
        do {
          val x: Any = pf.applyOrElse(rest.head, List.partialNotApplied)
          if (x.asInstanceOf[AnyRef] ne List.partialNotApplied) {
            val nx = new ::(x.asInstanceOf[B], Nil)
            t.tl = nx
            t = nx
          }
          rest = rest.tail
        } while (rest ne Nil)
        h.asInstanceOf[That]
      }
    }
    else super.collect(pf)
  }

  final override def flatMap[B, That](f: A => GenTraversableOnce[B])(implicit bf: CanBuildFrom[List[A], B, That]): That = {
    if (bf eq List.ReusableCBF) {
      if (this eq Nil) Nil.asInstanceOf[That] else {
        var rest = this
        var found = false
        var h: ::[B] = null
        var t: ::[B] = null
        while (rest ne Nil) {
          f(rest.head).seq.foreach{ b =>
            if (!found) {
              h = new ::(b, Nil)
              t = h
              found = true
            }
            else {
              val nx = new ::(b, Nil)
              t.tl = nx
              t = nx
            }
          }
          rest = rest.tail
        }
        (if (!found) Nil else h).asInstanceOf[That]
      }
    }
    else super.flatMap(f)
  }

  @inline final override def takeWhile(p: A => Boolean): List[A] = {
    val b = new ListBuffer[A]
    var these = this
    while (!these.isEmpty && p(these.head)) {
      b += these.head
      these = these.tail
    }
    b.toList
  }

  @inline final override def dropWhile(p: A => Boolean): List[A] = {
    @tailrec
    def loop(xs: List[A]): List[A] =
      if (xs.isEmpty || !p(xs.head)) xs
      else loop(xs.tail)

    loop(this)
  }

  @inline final override def span(p: A => Boolean): (List[A], List[A]) = {
    val b = new ListBuffer[A]
    var these = this
    while (!these.isEmpty && p(these.head)) {
      b += these.head
      these = these.tail
    }
    (b.toList, these)
  }

  // Overridden with an implementation identical to the inherited one (at this time)
  // solely so it can be finalized and thus inlinable.
  @inline final override def foreach[U](f: A => U) {
    var these = this
    while (!these.isEmpty) {
      f(these.head)
      these = these.tail
    }
  }

  override def reverse: List[A] = {
    var result: List[A] = Nil
    var these = this
    while (!these.isEmpty) {
      result = these.head :: result
      these = these.tail
    }
    result
  }

  override def foldRight[B](z: B)(op: (A, B) => B): B =
    reverse.foldLeft(z)((right, left) => op(left, right))

  override def stringPrefix = "List"

  override def toStream : Stream[A] =
    if (isEmpty) Stream.Empty
    else new Stream.Cons(head, tail.toStream)

  // Create a proxy for Java serialization that allows us to avoid mutation
  // during deserialization.  This is the Serialization Proxy Pattern.
  protected final def writeReplace(): AnyRef = new List.SerializationProxy(this)
}

/** The empty list.
 *
 *  @author  Martin Odersky
 *  @since   2.8
 */
@SerialVersionUID(0 - 8256821097970055419L)
case object Nil extends List[Nothing] {
  override def isEmpty = true
  override def head: Nothing =
    throw new NoSuchElementException("head of empty list")
  override def tail: List[Nothing] =
    throw new UnsupportedOperationException("tail of empty list")
  // Removal of equals method here might lead to an infinite recursion similar to IntMap.equals.
  override def equals(that: Any) = that match {
    case that1: scala.collection.GenSeq[_] => that1.isEmpty
    case _ => false
  }
}

/** A non empty list characterized by a head and a tail.
 *  @param head the first element of the list
 *  @param tl   the list containing the remaining elements of this list after the first one.
 *  @tparam B   the type of the list elements.
 *  @author  Martin Odersky
 *  @since   2.8
 */
@SerialVersionUID(509929039250432923L) // value computed by serialver for 2.11.2, annotation added in 2.11.4
final case class ::[B](override val head: B, private[scala] var tl: List[B]) extends List[B] {
  override def tail : List[B] = tl
  override def isEmpty: Boolean = false
}

/** $factoryInfo
 *  @define coll list
 *  @define Coll `List`
 */
object List extends SeqFactory[List] {
  /** $genericCanBuildFromInfo */
  implicit def canBuildFrom[A]: CanBuildFrom[Coll, A, List[A]] =
    ReusableCBF.asInstanceOf[GenericCanBuildFrom[A]]

  def newBuilder[A]: Builder[A, List[A]] = new ListBuffer[A]

  override def empty[A]: List[A] = Nil

  override def apply[A](xs: A*): List[A] = xs.toList

  private[collection] val partialNotApplied = new Function1[Any, Any] { def apply(x: Any): Any = this }

  @SerialVersionUID(1L)
  private class SerializationProxy[A](@transient private var orig: List[A]) extends Serializable {

    private def writeObject(out: ObjectOutputStream) {
      out.defaultWriteObject()
      var xs: List[A] = orig
      while (!xs.isEmpty) {
        out.writeObject(xs.head)
        xs = xs.tail
      }
      out.writeObject(ListSerializeEnd)
    }

    // Java serialization calls this before readResolve during deserialization.
    // Read the whole list and store it in `orig`.
    private def readObject(in: ObjectInputStream) {
      in.defaultReadObject()
      val builder = List.newBuilder[A]
      while (true) in.readObject match {
        case ListSerializeEnd =>
          orig = builder.result()
          return
        case a =>
          builder += a.asInstanceOf[A]
      }
    }

    // Provide the result stored in `orig` for Java serialization
    private def readResolve(): AnyRef = orig
  }
}

/** Only used for list serialization */
@SerialVersionUID(0L - 8476791151975527571L)
private[scala] case object ListSerializeEnd

/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala

import scala.language.implicitConversions

import scala.collection.{mutable, immutable, ArrayOps, StringOps}, immutable.WrappedString
import scala.annotation.{elidable, implicitNotFound}, elidable.ASSERTION
import scala.annotation.meta.{ companionClass, companionMethod }

/** The `Predef` object provides definitions that are accessible in all Scala
 *  compilation units without explicit qualification.
 *
 *  === Commonly Used Types ===
 *  Predef provides type aliases for types which are commonly used, such as
 *  the immutable collection types [[scala.collection.immutable.Map]],
 *  [[scala.collection.immutable.Set]], and the [[scala.collection.immutable.List]]
 *  constructors ([[scala.collection.immutable.::]] and
 *  [[scala.collection.immutable.Nil]]).
 *
 *  === Console Output ===
 *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],
 *  which are aliases of the methods in the object [[scala.Console]].
 *
 *  === Assertions ===
 *  A set of `assert` functions are provided for use as a way to document
 *  and dynamically check invariants in code. Invocations of `assert` can be elided
 *  at compile time by providing the command line option `-Xdisable-assertions`,
 *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.
 *
 *  Variants of `assert` intended for use with static analysis tools are also
 *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are
 *  intended for use as a means of design-by-contract style specification
 *  of pre- and post-conditions on functions, with the intention that these
 *  specifications could be consumed by a static analysis tool. For instance,
 *
 *  {{{
 *  def addNaturals(nats: List[Int]): Int = {
 *    require(nats forall (_ >= 0), "List contains negative numbers")
 *    nats.foldLeft(0)(_ + _)
 *  } ensuring(_ >= 0)
 *  }}}
 *
 *  The declaration of `addNaturals` states that the list of integers passed should
 *  only contain natural numbers (i.e. non-negative), and that the result returned
 *  will also be natural. `require` is distinct from `assert` in that if the
 *  condition fails, then the caller of the function is to blame rather than a
 *  logical error having been made within `addNaturals` itself. `ensuring` is a
 *  form of `assert` that declares the guarantee the function is providing with
 *  regards to its return value.
 *
 *  === Implicit Conversions ===
 *  A number of commonly applied implicit conversions are also defined here, and
 *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions
 *  are provided for the "widening" of numeric values, for instance, converting a
 *  Short value to a Long value as required, and to add additional higher-order
 *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].
 *
 * @groupname utilities Utility Methods
 * @groupprio utilities 10
 *
 * @groupname assertions Assertions
 * @groupprio assertions 20
 * @groupdesc assertions These methods support program verification and runtime correctness.
 *
 * @groupname console-output Console Output
 * @groupprio console-output 30
 * @groupdesc console-output These methods provide output via the console.
 *
 * @groupname aliases Aliases
 * @groupprio aliases 50
 * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.
 *
 * @groupname conversions-string String Conversions
 * @groupprio conversions-string 60
 * @groupdesc conversions-string Conversions from String to StringOps or WrappedString.
 *
 * @groupname implicit-classes-any Implicit Classes
 * @groupprio implicit-classes-any 70
 * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.
 *
 * @groupname implicit-classes-char CharSequence Conversions
 * @groupprio implicit-classes-char 80
 * @groupdesc implicit-classes-char These implicit classes add CharSequence methods to Array[Char] and IndexedSeq[Char] instances.
 *
 * @groupname conversions-java-to-anyval Java to Scala
 * @groupprio conversions-java-to-anyval 90
 * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.
 *
 * @groupname conversions-anyval-to-java Scala to Java
 * @groupprio conversions-anyval-to-java 100
 * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.
 *
 * @groupname conversions-array-to-wrapped-array Array to ArraySeq
 * @groupprio conversions-array-to-wrapped-array 110
 * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to ArraySeqs.
 */
object Predef extends LowPriorityImplicits {
  /**
   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to
   * the class literal `T.class` in Java.
   *
   * @example {{{
   * val listClass = classOf[List[_]]
   * // listClass is java.lang.Class[List[_]] = class scala.collection.immutable.List
   *
   * val mapIntString = classOf[Map[Int,String]]
   * // mapIntString is java.lang.Class[Map[Int,String]] = interface scala.collection.immutable.Map
   * }}}
   *
   * @return The runtime [[Class]] representation of type `T`.
   * @group utilities
   */
  def classOf[T]: Class[T] = null // This is a stub method. The actual implementation is filled in by the compiler.

  /**
   * Retrieve the single value of a type with a unique inhabitant.
   *
   * @example {{{
   * object Foo
   * val foo = valueOf[Foo.type]
   * // foo is Foo.type = Foo
   *
   * val bar = valueOf[23]
   * // bar is 23.type = 23
   * }}}
   * @group utilities
   */
  @inline def valueOf[T](implicit vt: ValueOf[T]): T = vt.value

  /** The `String` type in Scala has all the methods of the underlying
   *  `java.lang.String`, of which it is just an alias.
   *  (See the documentation corresponding to your Java version,
   *  for example [[http://docs.oracle.com/javase/8/docs/api/java/lang/String.html]].)
   *  In addition, extension methods in [[scala.collection.StringOps]]
   *  are added implicitly through the conversion [[augmentString]].
   *  @group aliases
   */
  type String        = java.lang.String
  /**  @group aliases */
  type Class[T]      = java.lang.Class[T]

  // miscellaneous -----------------------------------------------------
  scala.`package`                         // to force scala package object to be seen.
  scala.collection.immutable.List         // to force Nil, :: to be seen.

  /**  @group aliases */
  type Function[-A, +B] = Function1[A, B]

  /**  @group aliases */
  type Map[K, +V] = immutable.Map[K, V]
  /**  @group aliases */
  type Set[A]     = immutable.Set[A]
  /**  @group aliases */
  val Map         = immutable.Map
  /**  @group aliases */
  val Set         = immutable.Set

  /**
   * Allows destructuring tuples with the same syntax as constructing them.
   *
   * @example {{{
   * val tup = "foobar" -> 3
   *
   * val c = tup match {
   *   case str -> i => str.charAt(i)
   * }
   * }}}
   * @group aliases
   */
  val ->        = Tuple2

  // Manifest types, companions, and incantations for summoning
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  type OptManifest[T]   = scala.reflect.OptManifest[T]
  @implicitNotFound(msg = "No Manifest available for ${T}.")
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
  type Manifest[T]      = scala.reflect.Manifest[T]
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
  val Manifest          = scala.reflect.Manifest
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  val NoManifest        = scala.reflect.NoManifest

  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead", "2.10.0")
  def manifest[T](implicit m: Manifest[T]): Manifest[T]          = m
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  def optManifest[T](implicit m: OptManifest[T]): OptManifest[T] = m

  // Minor variations on identity functions

  /**
   * A method that returns its input value.
   * @tparam A type of the input value x.
   * @param x the value of type `A` to be returned.
   * @return the value `x`.
   * @group utilities */
  @inline def identity[A](x: A): A = x // see `$conforms` for the implicit version

  /** Summon an implicit value of type `T`. Usually, the argument is not passed explicitly.
   *
   *  @tparam T the type of the value to be summoned
   *  @return the implicit value of type `T`
   *  @group utilities
   */
  @inline def implicitly[T](implicit e: T): T = e // TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`

  /** Used to mark code blocks as being expressions, instead of being taken as part of anonymous classes and the like.
   *  This is just a different name for [[identity]].
   *
   *  @example Separating code blocks from `new`:
   *           {{{
   *             val x = new AnyRef
   *             {
   *               val y = ...
   *               println(y)
   *             }
   *             // the { ... } block is seen as the body of an anonymous class
   *
   *             val x = new AnyRef
   *
   *             {
   *               val y = ...
   *               println(y)
   *             }
   *             // an empty line is a brittle "fix"
   *
   *             val x = new AnyRef
   *             locally {
   *               val y = ...
   *               println(y)
   *             }
   *             // locally guards the block and helps communicate intent
   *           }}}
   *  @group utilities
   */
  @inline def locally[T](@deprecatedName("x") x: T): T = x

  // assertions ---------------------------------------------------------

  /** Tests an expression, throwing an `AssertionError` if false.
   *  Calls to this method will not be generated if `-Xelide-below`
   *  is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assertion   the expression to test
   *  @group assertions
   */
  @elidable(ASSERTION)
  def assert(assertion: Boolean): Unit = {
    if (!assertion)
      throw new java.lang.AssertionError("assertion failed")
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  Calls to this method will not be generated if `-Xelide-below`
   *  is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assertion   the expression to test
   *  @param message     a String to include in the failure message
   *  @group assertions
   */
  @elidable(ASSERTION) @inline
  final def assert(assertion: Boolean, message: => Any): Unit = {
    if (!assertion)
      throw new java.lang.AssertionError("assertion failed: "+ message)
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  This method differs from assert only in the intent expressed:
   *  assert contains a predicate which needs to be proven, while
   *  assume contains an axiom for a static checker.  Calls to this method
   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assumption   the expression to test
   *  @group assertions
   */
  @elidable(ASSERTION)
  def assume(assumption: Boolean): Unit = {
    if (!assumption)
      throw new java.lang.AssertionError("assumption failed")
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  This method differs from assert only in the intent expressed:
   *  assert contains a predicate which needs to be proven, while
   *  assume contains an axiom for a static checker.  Calls to this method
   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assumption   the expression to test
   *  @param message      a String to include in the failure message
   *  @group assertions
   */
  @elidable(ASSERTION) @inline
  final def assume(assumption: Boolean, message: => Any): Unit = {
    if (!assumption)
      throw new java.lang.AssertionError("assumption failed: "+ message)
  }

  /** Tests an expression, throwing an `IllegalArgumentException` if false.
   *  This method is similar to `assert`, but blames the caller of the method
   *  for violating the condition.
   *
   *  @param requirement   the expression to test
   *  @group assertions
   */
  def require(requirement: Boolean): Unit = {
    if (!requirement)
      throw new IllegalArgumentException("requirement failed")
  }

  /** Tests an expression, throwing an `IllegalArgumentException` if false.
   *  This method is similar to `assert`, but blames the caller of the method
   *  for violating the condition.
   *
   *  @param requirement   the expression to test
   *  @param message       a String to include in the failure message
   *  @group assertions
   */
  @inline final def require(requirement: Boolean, message: => Any): Unit = {
    if (!requirement)
      throw new IllegalArgumentException("requirement failed: "+ message)
  }

  /** `???` can be used for marking methods that remain to be implemented.
   *  @throws NotImplementedError when `???` is invoked.
   *  @group utilities
   */
  def ??? : Nothing = throw new NotImplementedError

  // implicit classes -----------------------------------------------------

  /** @group implicit-classes-any */
  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {
    @inline def -> [B](y: B): (A, B) = (self, y)
    @deprecated("Use `->` instead. If you still wish to display it as one character, consider using a font with programming ligatures such as Fira Code.", "2.13.0")
    def ?[B](y: B): (A, B) = ->(y)
  }

  /** @group implicit-classes-any */
  implicit final class Ensuring[A](private val self: A) extends AnyVal {
    def ensuring(cond: Boolean): A = { assert(cond); self }
    def ensuring(cond: Boolean, msg: => Any): A = { assert(cond, msg); self }
    def ensuring(cond: A => Boolean): A = { assert(cond(self)); self }
    def ensuring(cond: A => Boolean, msg: => Any): A = { assert(cond(self), msg); self }
  }

  /** @group implicit-classes-any */
  implicit final class StringFormat[A](private val self: A) extends AnyVal {
    /** Returns string formatted according to given `format` string.
     *  Format strings are as for `String.format`
     *  (@see java.lang.String.format).
     */
    @inline def formatted(fmtstr: String): String = fmtstr format self
  }

  /** Injects String concatenation operator `+` to any classes. 
   * @group implicit-classes-any
   */
  @(deprecated @companionMethod)("Implicit injection of + is deprecated. Convert to String to call +", "2.13.0")
  @(deprecated @companionClass)("Implicit injection of + is deprecated. Convert to String to call +", "2.13.0") // for Scaladoc
  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit
  implicit final class any2stringadd[A](private val self: A) extends AnyVal {
    def +(other: String): String = String.valueOf(self) + other
  }

  implicit final class SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {
    def length: Int                                     = sequenceOfChars.length
    def charAt(index: Int): Char                        = sequenceOfChars(index)
    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(sequenceOfChars.slice(start, end))
    override def toString                               = sequenceOfChars.mkString
  }

  /** @group implicit-classes-char */
  implicit final class ArrayCharSequence(arrayOfChars: Array[Char]) extends CharSequence {
    def length: Int                                     = arrayOfChars.length
    def charAt(index: Int): Char                        = arrayOfChars(index)
    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(arrayOfChars, start, end)
    override def toString                               = arrayOfChars.mkString
  }

  /** @group conversions-string */
  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)

  // printing -----------------------------------------------------------

  /** Prints an object to `out` using its `toString` method.
   *
   *  @param x the object to print; may be null.
   *  @group console-output
   */
  def print(x: Any): Unit = Console.print(x)

  /** Prints a newline character on the default output.
   *  @group console-output
   */
  def println(): Unit = Console.println()

  /** Prints out an object to the default output, followed by a newline character.
   *
   *  @param x the object to print.
   *  @group console-output
   */
  def println(x: Any): Unit = Console.println(x)

  /** Prints its arguments as a formatted string to the default output,
   *  based on a string pattern (in a fashion similar to printf in C).
   *
   *  The interpretation of the formatting patterns is described in
   *  [[java.util.Formatter]].
   *
   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.
   *
   *  @param text the pattern for formatting the arguments.
   *  @param xs   the arguments used to instantiate the pattern.
   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments
   *
   *  @see [[scala.StringContext.f StringContext.f]]
   *  @group console-output
   */
  def printf(text: String, xs: Any*): Unit = Console.print(text.format(xs: _*))

  // views --------------------------------------------------------------

  // these two are morally deprecated but the @deprecated annotation has been moved to the extension method themselves,
  // in order to provide a more specific deprecation method.
  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1, T2]             = new runtime.Tuple2Zipped.Ops(x)
  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1, T2, T3] = new runtime.Tuple3Zipped.Ops(x)

  // Not specialized anymore since 2.13 but we still need separate methods
  // to avoid https://github.com/scala/bug/issues/10746
  // TODO: should not need @inline. add heuristic to inline factories for value classes.
  @inline implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T]          = new ArrayOps(xs)
  @inline implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] = new ArrayOps(xs)
  @inline implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          = new ArrayOps(xs)
  @inline implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          = new ArrayOps(xs)
  @inline implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    = new ArrayOps(xs)
  @inline implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       = new ArrayOps(xs)
  @inline implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             = new ArrayOps(xs)
  @inline implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          = new ArrayOps(xs)
  @inline implicit def refArrayOps[T <: AnyRef](xs: Array[T]): ArrayOps[T]    = new ArrayOps(xs)
  @inline implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       = new ArrayOps(xs)
  @inline implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          = new ArrayOps(xs)

  // "Autoboxing" and "Autounboxing" ---------------------------------------------------

  /** @group conversions-anyval-to-java */
  implicit def byte2Byte(x: Byte): java.lang.Byte             = x.asInstanceOf[java.lang.Byte]
  /** @group conversions-anyval-to-java */
  implicit def short2Short(x: Short): java.lang.Short         = x.asInstanceOf[java.lang.Short]
  /** @group conversions-anyval-to-java */
  implicit def char2Character(x: Char): java.lang.Character   = x.asInstanceOf[java.lang.Character]
  /** @group conversions-anyval-to-java */
  implicit def int2Integer(x: Int): java.lang.Integer         = x.asInstanceOf[java.lang.Integer]
  /** @group conversions-anyval-to-java */
  implicit def long2Long(x: Long): java.lang.Long             = x.asInstanceOf[java.lang.Long]
  /** @group conversions-anyval-to-java */
  implicit def float2Float(x: Float): java.lang.Float         = x.asInstanceOf[java.lang.Float]
  /** @group conversions-anyval-to-java */
  implicit def double2Double(x: Double): java.lang.Double     = x.asInstanceOf[java.lang.Double]
  /** @group conversions-anyval-to-java */
  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean = x.asInstanceOf[java.lang.Boolean]

  /** @group conversions-java-to-anyval */
  implicit def Byte2byte(x: java.lang.Byte): Byte             = x.asInstanceOf[Byte]
  /** @group conversions-java-to-anyval */
  implicit def Short2short(x: java.lang.Short): Short         = x.asInstanceOf[Short]
  /** @group conversions-java-to-anyval */
  implicit def Character2char(x: java.lang.Character): Char   = x.asInstanceOf[Char]
  /** @group conversions-java-to-anyval */
  implicit def Integer2int(x: java.lang.Integer): Int         = x.asInstanceOf[Int]
  /** @group conversions-java-to-anyval */
  implicit def Long2long(x: java.lang.Long): Long             = x.asInstanceOf[Long]
  /** @group conversions-java-to-anyval */
  implicit def Float2float(x: java.lang.Float): Float         = x.asInstanceOf[Float]
  /** @group conversions-java-to-anyval */
  implicit def Double2double(x: java.lang.Double): Double     = x.asInstanceOf[Double]
  /** @group conversions-java-to-anyval */
  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean = x.asInstanceOf[Boolean]

  /** An implicit of type `A => A` is available for all `A` because it can always
   *  be implemented using the identity function. This also means that an
   *  implicit of type `A => B` is always available when `A <: B`, because
   *  `(A => A) <: (A => B)`.
   */
  // $ to avoid accidental shadowing (e.g. scala/bug#7788)
  implicit def $conforms[A]: A => A = <:<.refl
}

/** The `LowPriorityImplicits` class provides implicit values that
*  are valid in all Scala compilation units without explicit qualification,
*  but that are partially overridden by higher-priority conversions in object
*  `Predef`.
*/
// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid
// cyclic reference errors compiling the standard library *without* a previously
// compiled copy on the classpath.
private[scala] abstract class LowPriorityImplicits extends LowPriorityImplicits2 {
  import mutable.ArraySeq

  /** We prefer the java.lang.* boxed types to these wrappers in
   *  any potential conflicts.  Conflicts do exist because the wrappers
   *  need to implement ScalaNumber in order to have a symmetric equals
   *  method, but that implies implementing java.lang.Number as well.
   *
   *  Note - these are inlined because they are value classes, but
   *  the call to xxxWrapper is not eliminated even though it does nothing.
   *  Even inlined, every call site does a no-op retrieval of Predef's MODULE$
   *  because maybe loading Predef has side effects!
   */
  @inline implicit def byteWrapper(x: Byte): runtime.RichByte          = new runtime.RichByte(x)
  @inline implicit def shortWrapper(x: Short): runtime.RichShort       = new runtime.RichShort(x)
  @inline implicit def intWrapper(x: Int): runtime.RichInt             = new runtime.RichInt(x)
  @inline implicit def charWrapper(c: Char): runtime.RichChar          = new runtime.RichChar(c)
  @inline implicit def longWrapper(x: Long): runtime.RichLong          = new runtime.RichLong(x)
  @inline implicit def floatWrapper(x: Float): runtime.RichFloat       = new runtime.RichFloat(x)
  @inline implicit def doubleWrapper(x: Double): runtime.RichDouble    = new runtime.RichDouble(x)
  @inline implicit def booleanWrapper(x: Boolean): runtime.RichBoolean = new runtime.RichBoolean(x)

  /** @group conversions-array-to-wrapped-array */
  implicit def genericWrapArray[T](xs: Array[T]): ArraySeq[T] =
    if (xs eq null) null
    else ArraySeq.make(xs)

  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]
  // is as good as another for all T <: AnyRef.  Instead of creating 100,000,000
  // unique ones by way of this implicit, let's share one.
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapRefArray[T <: AnyRef](xs: Array[T]): ArraySeq.ofRef[T] = {
    if (xs eq null) null
    else if (xs.length == 0) ArraySeq.empty[AnyRef].asInstanceOf[ArraySeq.ofRef[T]]
    else new ArraySeq.ofRef[T](xs)
  }

  /** @group conversions-array-to-wrapped-array */
  implicit def wrapIntArray(xs: Array[Int]): ArraySeq.ofInt = if (xs ne null) new ArraySeq.ofInt(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapDoubleArray(xs: Array[Double]): ArraySeq.ofDouble = if (xs ne null) new ArraySeq.ofDouble(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapLongArray(xs: Array[Long]): ArraySeq.ofLong = if (xs ne null) new ArraySeq.ofLong(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapFloatArray(xs: Array[Float]): ArraySeq.ofFloat = if (xs ne null) new ArraySeq.ofFloat(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapCharArray(xs: Array[Char]): ArraySeq.ofChar = if (xs ne null) new ArraySeq.ofChar(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapByteArray(xs: Array[Byte]): ArraySeq.ofByte = if (xs ne null) new ArraySeq.ofByte(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapShortArray(xs: Array[Short]): ArraySeq.ofShort = if (xs ne null) new ArraySeq.ofShort(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapBooleanArray(xs: Array[Boolean]): ArraySeq.ofBoolean = if (xs ne null) new ArraySeq.ofBoolean(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapUnitArray(xs: Array[Unit]): ArraySeq.ofUnit = if (xs ne null) new ArraySeq.ofUnit(xs) else null

  /** @group conversions-string */
  implicit def wrapString(s: String): WrappedString = if (s ne null) new WrappedString(s) else null
}

private[scala] abstract class LowPriorityImplicits2 {
  @deprecated("Implicit conversions from Array to immutable.IndexedSeq are implemented by copying; Use the more efficient non-copying ArraySeq.unsafeWrapArray or an explicit toIndexedSeq call", "2.13.0")
  implicit def copyArrayToImmutableIndexedSeq[T](xs: Array[T]): IndexedSeq[T] =
    if (xs eq null) null
    else new ArrayOps(xs).toIndexedSeq
}

[0m2021.03.16 00:25:27 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:25:27 INFO  time: compiled root in 0.1s[0m
[0m2021.03.16 00:25:32 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:25:32 INFO  time: compiled root in 0.1s[0m
[0m2021.03.16 00:25:39 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:25:39 INFO  time: compiled root in 0.1s[0m
[0m2021.03.16 00:25:43 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:25:43 INFO  time: compiled root in 0.1s[0m
[0m2021.03.16 00:27:07 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:27:07 INFO  time: compiled root in 0.1s[0m
[0m2021.03.16 00:27:49 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:27:49 INFO  time: compiled root in 99ms[0m
[0m2021.03.16 00:28:09 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:28:09 INFO  time: compiled root in 0.1s[0m
[0m2021.03.16 00:28:43 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:28:43 INFO  time: compiled root in 0.12s[0m
[0m2021.03.16 00:28:45 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:28:45 INFO  time: compiled root in 0.59s[0m
[0m2021.03.16 00:28:45 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:28:45 INFO  time: compiled root in 93ms[0m
[0m2021.03.16 00:30:11 INFO  compiling root (2 scala sources)[0m
[0m2021.03.16 00:30:11 INFO  time: compiled root in 0.12s[0m
[0m2021.03.16 00:30:23 INFO  compiling root (2 scala sources)[0m
[0m2021.03.16 00:30:23 INFO  time: compiled root in 0.12s[0m
[0m2021.03.16 00:34:09 INFO  compiling root (2 scala sources)[0m
[0m2021.03.16 00:34:09 INFO  time: compiled root in 0.83s[0m
[0m2021.03.16 00:34:09 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:34:10 INFO  time: compiled root in 0.27s[0m
[0m2021.03.16 00:39:12 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:39:12 INFO  time: compiled root in 0.34s[0m
[0m2021.03.16 00:39:20 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:39:20 INFO  time: compiled root in 0.24s[0m
[0m2021.03.16 00:40:05 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:40:05 INFO  time: compiled root in 98ms[0m
[0m2021.03.16 00:40:13 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:40:13 INFO  time: compiled root in 0.21s[0m
[0m2021.03.16 00:40:19 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:40:19 INFO  time: compiled root in 95ms[0m
Mar 16, 2021 12:40:20 AM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: String index out of range: -25
Mar 16, 2021 12:40:20 AM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: String index out of range: -25
Mar 16, 2021 12:40:21 AM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: String index out of range: -25
Mar 16, 2021 12:40:21 AM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: String index out of range: -25
Mar 16, 2021 12:40:22 AM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: String index out of range: -25
[0m2021.03.16 00:40:23 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:40:23 INFO  time: compiled root in 96ms[0m
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

/**
 * Core Scala types. They are always available without an explicit import.
 * @contentDiagram hideNodes "scala.Serializable"
 */
package object scala {
  type Throwable = java.lang.Throwable
  type Exception = java.lang.Exception
  type Error     = java.lang.Error

  type RuntimeException                = java.lang.RuntimeException
  type NullPointerException            = java.lang.NullPointerException
  type ClassCastException              = java.lang.ClassCastException
  type IndexOutOfBoundsException       = java.lang.IndexOutOfBoundsException
  type ArrayIndexOutOfBoundsException  = java.lang.ArrayIndexOutOfBoundsException
  type StringIndexOutOfBoundsException = java.lang.StringIndexOutOfBoundsException
  type UnsupportedOperationException   = java.lang.UnsupportedOperationException
  type IllegalArgumentException        = java.lang.IllegalArgumentException
  type NoSuchElementException          = java.util.NoSuchElementException
  type NumberFormatException           = java.lang.NumberFormatException
  type AbstractMethodError             = java.lang.AbstractMethodError
  type InterruptedException            = java.lang.InterruptedException

  // A dummy used by the specialization annotation.
  val AnyRef = new Specializable {
    override def toString = "object AnyRef"
  }

  type TraversableOnce[+A] = scala.collection.TraversableOnce[A]

  type Traversable[+A] = scala.collection.Traversable[A]
  val Traversable = scala.collection.Traversable

  type Iterable[+A] = scala.collection.Iterable[A]
  val Iterable = scala.collection.Iterable

  type Seq[+A] = scala.collection.Seq[A]
  val Seq = scala.collection.Seq

  type IndexedSeq[+A] = scala.collection.IndexedSeq[A]
  val IndexedSeq = scala.collection.IndexedSeq

  type Iterator[+A] = scala.collection.Iterator[A]
  val Iterator = scala.collection.Iterator

  type BufferedIterator[+A] = scala.collection.BufferedIterator[A]

  type List[+A] = scala.collection.immutable.List[A]
  val List = scala.collection.immutable.List

  val Nil = scala.collection.immutable.Nil

  type ::[A] = scala.collection.immutable.::[A]
  val :: = scala.collection.immutable.::

  val +: = scala.collection.+:
  val :+ = scala.collection.:+

  type Stream[+A] = scala.collection.immutable.Stream[A]
  val Stream = scala.collection.immutable.Stream
  val #:: = scala.collection.immutable.Stream.#::

  type Vector[+A] = scala.collection.immutable.Vector[A]
  val Vector = scala.collection.immutable.Vector

  type StringBuilder = scala.collection.mutable.StringBuilder
  val StringBuilder = scala.collection.mutable.StringBuilder

  type Range = scala.collection.immutable.Range
  val Range = scala.collection.immutable.Range

  // Numeric types which were moved into scala.math.*

  type BigDecimal = scala.math.BigDecimal
  val BigDecimal = scala.math.BigDecimal

  type BigInt = scala.math.BigInt
  val BigInt = scala.math.BigInt

  type Equiv[T] = scala.math.Equiv[T]
  val Equiv = scala.math.Equiv

  type Fractional[T] = scala.math.Fractional[T]
  val Fractional = scala.math.Fractional

  type Integral[T] = scala.math.Integral[T]
  val Integral = scala.math.Integral

  type Numeric[T] = scala.math.Numeric[T]
  val Numeric = scala.math.Numeric

  type Ordered[T] = scala.math.Ordered[T]
  val Ordered = scala.math.Ordered

  type Ordering[T] = scala.math.Ordering[T]
  val Ordering = scala.math.Ordering

  type PartialOrdering[T] = scala.math.PartialOrdering[T]
  type PartiallyOrdered[T] = scala.math.PartiallyOrdered[T]

  type Either[+A, +B] = scala.util.Either[A, B]
  val Either = scala.util.Either

  type Left[+A, +B] = scala.util.Left[A, B]
  val Left = scala.util.Left

  type Right[+A, +B] = scala.util.Right[A, B]
  val Right = scala.util.Right

  // Annotations which we might move to annotation.*
/*
  type SerialVersionUID = annotation.SerialVersionUID
  type deprecated = annotation.deprecated
  type deprecatedName = annotation.deprecatedName
  type inline = annotation.inline
  type native = annotation.native
  type noinline = annotation.noinline
  type remote = annotation.remote
  type specialized = annotation.specialized
  type transient = annotation.transient
  type throws  = annotation.throws
  type unchecked = annotation.unchecked.unchecked
  type volatile = annotation.volatile
  */
}

[0m2021.03.16 00:40:44 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:40:44 INFO  time: compiled root in 0.22s[0m
[0m2021.03.16 00:40:47 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:40:47 INFO  time: compiled root in 0.14s[0m
[0m2021.03.16 00:41:03 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:41:03 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:41:46 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:41:46 INFO  time: compiled root in 96ms[0m
[0m2021.03.16 00:42:10 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:42:10 INFO  time: compiled root in 0.6s[0m
[0m2021.03.16 00:42:10 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:42:10 INFO  time: compiled root in 89ms[0m
Mar 16, 2021 12:42:18 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10049
Mar 16, 2021 12:43:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10079
[0m2021.03.16 00:43:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:43:33 INFO  time: compiled root in 0.11s[0m
[0m2021.03.16 00:43:39 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:43:39 INFO  time: compiled root in 97ms[0m
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala
package collection
package mutable

import generic._
import immutable.{List, Nil, ::}
import java.io.{ObjectOutputStream, ObjectInputStream}

/** A `Buffer` implementation backed by a list. It provides constant time
 *  prepend and append. Most other operations are linear.
 *
 *  @author  Matthias Zenger
 *  @author  Martin Odersky
 *  @since   1
 *  @see [[http://docs.scala-lang.org/overviews/collections/concrete-mutable-collection-classes.html#list-buffers "Scala's Collection Library overview"]]
 *  section on `List Buffers` for more information.
 *
 *  @tparam A    the type of this list buffer's elements.
 *
 *  @define Coll `ListBuffer`
 *  @define coll list buffer
 *  @define thatinfo the class of the returned collection. In the standard library configuration,
 *    `That` is always `ListBuffer[B]` because an implicit of type `CanBuildFrom[ListBuffer, B, ListBuffer[B]]`
 *    is defined in object `ListBuffer`.
 *  @define bfinfo an implicit value of class `CanBuildFrom` which determines the
 *    result class `That` from the current representation type `Repr`
 *    and the new element type `B`. This is usually the `canBuildFrom` value
 *    defined in object `ListBuffer`.
 *  @define orderDependent
 *  @define orderDependentFold
 *  @define mayNotTerminateInf
 *  @define willNotTerminateInf
 */
@SerialVersionUID(3419063961353022662L)
final class ListBuffer[A]
      extends AbstractBuffer[A]
         with Buffer[A]
         with GenericTraversableTemplate[A, ListBuffer]
         with BufferLike[A, ListBuffer[A]]
         with ReusableBuilder[A, List[A]]
         with SeqForwarder[A]
         with Serializable
{
  override def companion: GenericCompanion[ListBuffer] = ListBuffer

  import scala.collection.Traversable
  import scala.collection.immutable.ListSerializeEnd

  /** Expected invariants:
   *  If start.isEmpty, last0 == null
   *  If start.nonEmpty, last0 != null
   *  If len == 0, start.isEmpty
   *  If len > 0, start.nonEmpty
   */
  private var start: List[A] = Nil
  private var last0: ::[A] = _
  private[this] var exported: Boolean = false
  private[this] var len = 0

  protected def underlying: List[A] = start

  private def writeObject(out: ObjectOutputStream) {
    // write start
    var xs: List[A] = start
    while (!xs.isEmpty) { out.writeObject(xs.head); xs = xs.tail }
    out.writeObject(ListSerializeEnd)

    // no need to write last0

    // write if exported
    out.writeBoolean(exported)

    // write the length
    out.writeInt(len)
  }

  private def readObject(in: ObjectInputStream) {
    // read start, set last0 appropriately
    var elem: A = in.readObject.asInstanceOf[A]
    if (elem == ListSerializeEnd) {
      start = Nil
      last0 = null
    } else {
      var current = new ::(elem, Nil)
      start = current
      elem = in.readObject.asInstanceOf[A]
      while (elem != ListSerializeEnd) {
        val list = new ::(elem, Nil)
        current.tl = list
        current = list
        elem = in.readObject.asInstanceOf[A]
      }
      last0 = current
      start
    }

    // read if exported
    exported = in.readBoolean()

    // read the length
    len = in.readInt()
  }

  /** The current length of the buffer.
   *
   *  This operation takes constant time.
   */
  override def length = len

  // Don't use the inherited size, which forwards to a List and is O(n).
  override def size = length

  // Override with efficient implementations using the extra size information available to ListBuffer.
  override def isEmpty: Boolean = len == 0
  override def nonEmpty: Boolean = len > 0

  // Implementations of abstract methods in Buffer

  override def apply(n: Int): A =
    if (n < 0 || n >= len) throw new IndexOutOfBoundsException(n.toString())
    else super.apply(n)

  /** Replaces element at index `n` with the new element
   *  `newelem`. Takes time linear in the buffer size. (except the
   *  first element, which is updated in constant time).
   *
   *  @param n  the index of the element to replace.
   *  @param x  the new element.
   *  @throws IndexOutOfBoundsException if `n` is out of bounds.
   */
  def update(n: Int, x: A) {
    // We check the bounds early, so that we don't trigger copying.
    if (n < 0 || n >= len) throw new IndexOutOfBoundsException(n.toString)
    ensureUnaliased()
    if (n == 0) {
      val newElem = new :: (x, start.tail)
      if (last0 eq start) {
        last0 = newElem
      }
      start = newElem
    } else {
      var cursor = start
      var i = 1
      while (i < n) {
        cursor = cursor.tail
        i += 1
      }
      val newElem = new :: (x, cursor.tail.tail)
      if (last0 eq cursor.tail) {
        last0 = newElem
      }
      cursor.asInstanceOf[::[A]].tl = newElem
    }
  }

  /** Appends a single element to this buffer. This operation takes constant time.
   *
   *  @param x  the element to append.
   *  @return   this $coll.
   */
  def += (x: A): this.type = {
    ensureUnaliased()
    val last1 = new ::[A](x, Nil)
    if (len == 0) start = last1 else last0.tl = last1
    last0 = last1
    len += 1
    this
  }

  override def ++=(xs: TraversableOnce[A]): this.type = xs match {
    case x: AnyRef if x eq this      => this ++= (this take size)
    case _                           => super.++=(xs)

  }

  override def ++=:(xs: TraversableOnce[A]): this.type =
    if (xs.asInstanceOf[AnyRef] eq this) ++=: (this take size) else super.++=:(xs)

  /** Clears the buffer contents.
   */
  def clear() {
    start = Nil
    last0 = null
    exported = false
    len = 0
  }

  /** Prepends a single element to this buffer. This operation takes constant
   *  time.
   *
   *  @param x  the element to prepend.
   *  @return   this $coll.
   */
  def +=: (x: A): this.type = {
    ensureUnaliased()
    val newElem = new :: (x, start)
    if (isEmpty) last0 = newElem
    start = newElem
    len += 1
    this
  }

  /** Inserts new elements at the index `n`. Opposed to method
   *  `update`, this method will not replace an element with a new
   *  one. Instead, it will insert a new element at index `n`.
   *
   *  @param  n     the index where a new element will be inserted.
   *  @param  seq   the iterable object providing all elements to insert.
   *  @throws IndexOutOfBoundsException if `n` is out of bounds.
   */
  def insertAll(n: Int, seq: Traversable[A]) {
    // We check the bounds early, so that we don't trigger copying.
    if (n < 0 || n > len) throw new IndexOutOfBoundsException(n.toString)
    ensureUnaliased()
    var elems = seq.toList.reverse
    len += elems.length
    if (n == 0) {
      while (!elems.isEmpty) {
        val newElem = new :: (elems.head, start)
        if (start.isEmpty) last0 = newElem
        start = newElem
        elems = elems.tail
      }
    } else {
      var cursor = start
      var i = 1
      while (i < n) {
        cursor = cursor.tail
        i += 1
      }
      while (!elems.isEmpty) {
        val newElem = new :: (elems.head, cursor.tail)
        if (cursor.tail.isEmpty) last0 = newElem
        cursor.asInstanceOf[::[A]].tl = newElem
        elems = elems.tail
      }
    }
  }

  /** Reduce the length of the buffer, and null out last0
   *  if this reduces the length to 0.
   */
  private def reduceLengthBy(num: Int) {
    len -= num
    if (len <= 0)   // obviously shouldn't be < 0, but still better not to leak
      last0 = null
  }

  /** Removes a given number of elements on a given index position. May take
   *  time linear in the buffer size.
   *
   *  @param n         the index which refers to the first element to remove.
   *  @param count     the number of elements to remove.
   *  @throws   IndexOutOfBoundsException if the index `n` is not in the valid range
   *            `0 <= n <= length - count` (with `count > 0`).
   *  @throws   IllegalArgumentException if `count < 0`.
   */
  override def remove(n: Int, count: Int) {
    if (count < 0) throw new IllegalArgumentException("removing negative number of elements: " + count.toString)
    else if (count == 0) return  // Nothing to do
    if (n < 0 || n > len - count) throw new IndexOutOfBoundsException("at " + n.toString + " deleting " + count.toString)
    ensureUnaliased()
    val n1 = n max 0
    val count1 = count min (len - n1)
    if (n1 == 0) {
      var c = count1
      while (c > 0) {
        start = start.tail
        c -= 1
      }
    } else {
      var cursor = start
      var i = 1
      while (i < n1) {
        cursor = cursor.tail
        i += 1
      }
      var c = count1
      while (c > 0) {
        if (last0 eq cursor.tail) last0 = cursor.asInstanceOf[::[A]]
        cursor.asInstanceOf[::[A]].tl = cursor.tail.tail
        c -= 1
      }
    }
    reduceLengthBy(count1)
  }

// Implementation of abstract method in Builder

  /** Returns the accumulated `List`.
   *
   *  This method may be called multiple times to obtain snapshots of the list in different stages of construction.
   */
  def result: List[A] = toList

  /** Converts this buffer to a list. Takes constant time. The buffer is
   *  copied lazily, the first time it is mutated.
   */
  override def toList: List[A] = {
    exported = !isEmpty
    start
  }

// New methods in ListBuffer

  /** Prepends the elements of this buffer to a given list
   *
   *  @param xs   the list to which elements are prepended
   */
  def prependToList(xs: List[A]): List[A] = {
    if (isEmpty) xs
    else {
      ensureUnaliased()
      last0.tl = xs
      toList
    }
  }

// Overrides of methods in Buffer

  /** Removes the element on a given index position. May take time linear in
   *  the buffer size.
   *
   *  @param  n  the index which refers to the element to delete.
   *  @return n  the element that was formerly at position `n`.
   *  @note      an element must exists at position `n`.
   *  @throws IndexOutOfBoundsException if `n` is out of bounds.
   */
  def remove(n: Int): A = {
    if (n < 0 || n >= len) throw new IndexOutOfBoundsException(n.toString())
    ensureUnaliased()
    var old = start.head
    if (n == 0) {
      start = start.tail
    } else {
      var cursor = start
      var i = 1
      while (i < n) {
        cursor = cursor.tail
        i += 1
      }
      old = cursor.tail.head
      if (last0 eq cursor.tail) last0 = cursor.asInstanceOf[::[A]]
      cursor.asInstanceOf[::[A]].tl = cursor.tail.tail
    }
    reduceLengthBy(1)
    old
  }

  /** Remove a single element from this buffer. May take time linear in the
   *  buffer size.
   *
   *  @param elem  the element to remove.
   *  @return      this $coll.
   */
  override def -= (elem: A): this.type = {
    ensureUnaliased()
    if (isEmpty) {}
    else if (start.head == elem) {
      start = start.tail
      reduceLengthBy(1)
    }
    else {
      var cursor = start
      while (!cursor.tail.isEmpty && cursor.tail.head != elem) {
        cursor = cursor.tail
      }
      if (!cursor.tail.isEmpty) {
        val z = cursor.asInstanceOf[::[A]]
        if (z.tl == last0)
          last0 = z
        z.tl = cursor.tail.tail
        reduceLengthBy(1)
      }
    }
    this
  }

  /** Selects the last element.
   *
   *  Runs in constant time.
   *
   *  @return the last element of this buffer.
   *  @throws NoSuchElementException if this buffer is empty.
   */
  override def last: A =
    if (last0 eq null) throw new NoSuchElementException("last of empty ListBuffer")
    else last0.head

  /** Optionally selects the last element.
   *
   *  Runs in constant time.
   *
   *  @return `Some` of the last element of this buffer if the buffer is nonempty, `None` if it is empty.
   */
  override def lastOption: Option[A] = if (last0 eq null) None else Some(last0.head)

  /** Returns an iterator over this `ListBuffer`.  The iterator will reflect
   *  changes made to the underlying `ListBuffer` beyond the next element;
   *  the next element's value is cached so that `hasNext` and `next` are
   *  guaranteed to be consistent.  In particular, an empty `ListBuffer`
   *  will give an empty iterator even if the `ListBuffer` is later filled.
   */
  override def iterator: Iterator[A] = new AbstractIterator[A] {
    // Have to be careful iterating over mutable structures.
    // This used to have "(cursor ne last0)" as part of its hasNext
    // condition, which means it can return true even when the iterator
    // is exhausted.  Inconsistent results are acceptable when one mutates
    // a structure while iterating, but we should never return hasNext == true
    // on exhausted iterators (thus creating exceptions) merely because
    // values were changed in-place.
    var cursor: List[A] = if (ListBuffer.this.isEmpty) Nil else start

    def hasNext: Boolean = cursor ne Nil
    def next(): A =
      if (!hasNext) throw new NoSuchElementException("next on empty Iterator")
      else {
        val ans = cursor.head
        cursor = cursor.tail
        ans
      }
  }

  // Private methods
  private def ensureUnaliased() = {
    if (exported) copy()
  }

  /** Copy contents of this buffer */
  private def copy() {
    if (isEmpty) return
    var cursor = start
    val limit = last0.tail
    clear()
    while (cursor ne limit) {
      this += cursor.head
      cursor = cursor.tail
    }
  }

  override def equals(that: Any): Boolean = that match {
    case that: ListBuffer[_] => this.start equals that.start
    case _                   => super.equals(that)
  }

  /** Returns a clone of this buffer.
   *
   *  @return a `ListBuffer` with the same elements.
   */
  override def clone(): ListBuffer[A] = (new ListBuffer[A]) ++= this

  /** Defines the prefix of the string representation.
   *
   *  @return the string representation of this buffer.
   */
  override def stringPrefix: String = "ListBuffer"
}

/** $factoryInfo
 *  @define Coll `ListBuffer`
 *  @define coll list buffer
 */
object ListBuffer extends SeqFactory[ListBuffer] {
  implicit def canBuildFrom[A]: CanBuildFrom[Coll, A, ListBuffer[A]] = ReusableCBF.asInstanceOf[GenericCanBuildFrom[A]]
  def newBuilder[A]: Builder[A, ListBuffer[A]] = new GrowingBuilder(new ListBuffer[A])
}

[0m2021.03.16 00:44:02 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:44:02 INFO  time: compiled root in 99ms[0m
[0m2021.03.16 00:44:04 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:44:04 INFO  time: compiled root in 98ms[0m
[0m2021.03.16 00:45:29 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:45:29 INFO  time: compiled root in 0.11s[0m
[0m2021.03.16 00:45:51 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:45:51 INFO  time: compiled root in 0.11s[0m
[0m2021.03.16 00:46:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:46:33 INFO  time: compiled root in 95ms[0m
[0m2021.03.16 00:46:39 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:46:39 INFO  time: compiled root in 0.6s[0m
[0m2021.03.16 00:46:39 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:46:39 INFO  time: compiled root in 0.12s[0m
Mar 16, 2021 12:47:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10698
[0m2021.03.16 00:48:05 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:48:05 INFO  time: compiled root in 0.23s[0m
[0m2021.03.16 00:48:21 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:48:21 INFO  time: compiled root in 0.19s[0m
Mar 16, 2021 12:48:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10838
Mar 16, 2021 12:48:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10871
[0m2021.03.16 00:50:22 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:50:22 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:51:44 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:51:44 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:51:57 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:51:57 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:53:00 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:53:00 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:53:30 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:53:30 INFO  time: compiled root in 0.22s[0m
[0m2021.03.16 00:54:56 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:54:56 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:55:17 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:55:17 INFO  time: compiled root in 0.23s[0m
[0m2021.03.16 00:55:22 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:55:22 INFO  time: compiled root in 88ms[0m
[0m2021.03.16 00:55:26 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:55:26 INFO  time: compiled root in 0.22s[0m
[0m2021.03.16 00:55:38 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:55:38 INFO  time: compiled root in 0.18s[0m
Mar 16, 2021 12:55:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11863
[0m2021.03.16 00:58:11 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:58:11 INFO  time: compiled root in 0.2s[0m
[0m2021.03.16 00:58:19 INFO  compiling root (10 scala sources and 1 java source)[0m
[0m2021.03.16 00:58:21 INFO  time: compiled root in 1.48s[0m
[0m2021.03.16 00:58:59 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:58:59 INFO  time: compiled root in 0.73s[0m
Mar 16, 2021 12:59:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12040
[0m2021.03.16 00:59:43 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 00:59:43 INFO  time: compiled root in 0.75s[0m
[0m2021.03.16 01:00:05 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:00:05 INFO  time: compiled root in 0.77s[0m
Mar 16, 2021 1:00:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12109
[0m2021.03.16 01:00:58 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:00:58 INFO  time: compiled root in 0.72s[0m
[0m2021.03.16 01:04:06 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:04:06 INFO  time: compiled root in 0.65s[0m
Mar 16, 2021 1:04:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12376
[0m2021.03.16 01:04:11 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:04:11 INFO  time: compiled root in 93ms[0m
[0m2021.03.16 01:04:17 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:04:17 INFO  time: compiled root in 91ms[0m
[0m2021.03.16 01:04:25 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:04:25 INFO  time: compiled root in 93ms[0m
[0m2021.03.16 01:04:48 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:04:48 INFO  time: compiled root in 0.63s[0m
Mar 16, 2021 1:07:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12631
Mar 16, 2021 1:08:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12703
Mar 16, 2021 1:09:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12810
Mar 16, 2021 1:09:16 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 16, 2021 1:09:16 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: null
java.lang.NullPointerException
	at scala.reflect.internal.Definitions$DefinitionsClass.isByNameParamType(Definitions.scala:419)
	at scala.reflect.internal.TreeInfo.isStableIdent(TreeInfo.scala:136)
	at scala.reflect.internal.TreeInfo.isStableIdentifier(TreeInfo.scala:109)
	at scala.reflect.internal.TreeInfo.isPath(TreeInfo.scala:98)
	at scala.tools.nsc.interactive.Global.stabilizedType(Global.scala:963)
	at scala.tools.nsc.interactive.Global.typedTreeAt(Global.scala:811)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:23)

[0m2021.03.16 01:09:31 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:09:31 INFO  time: compiled root in 0.67s[0m
Mar 16, 2021 1:09:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12942
Mar 16, 2021 1:10:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13163
[0m2021.03.16 01:10:41 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:10:41 INFO  time: compiled root in 0.74s[0m
Mar 16, 2021 1:13:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13216
[0m2021.03.16 01:14:21 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:14:21 INFO  time: compiled root in 0.65s[0m
[0m2021.03.16 01:19:14 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:19:14 INFO  time: compiled root in 0.67s[0m
[0m2021.03.16 01:20:11 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:20:11 INFO  time: compiled root in 0.66s[0m
[0m2021.03.16 01:21:15 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:21:15 INFO  time: compiled root in 0.66s[0m
[0m2021.03.16 01:22:46 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:22:46 INFO  time: compiled root in 0.96s[0m
Mar 16, 2021 1:30:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13807
Mar 16, 2021 1:31:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13848
Mar 16, 2021 1:32:54 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: String index out of range: -12
java.lang.StringIndexOutOfBoundsException: String index out of range: -12
	at java.lang.String.<init>(String.java:196)
	at scala.tools.nsc.interactive.Global.typeCompletions$1(Global.scala:1235)
	at scala.tools.nsc.interactive.Global.completionsAt(Global.scala:1258)
	at scala.meta.internal.pc.SignatureHelpProvider.$anonfun$treeSymbol$1(SignatureHelpProvider.scala:375)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.pc.SignatureHelpProvider.treeSymbol(SignatureHelpProvider.scala:373)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCall$.unapply(SignatureHelpProvider.scala:198)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.visit(SignatureHelpProvider.scala:309)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.traverse(SignatureHelpProvider.scala:303)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.$anonfun$visit$5(SignatureHelpProvider.scala:339)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.$anonfun$visit$5$adapted(SignatureHelpProvider.scala:316)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:553)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:551)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:920)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:890)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.$anonfun$visit$3(SignatureHelpProvider.scala:316)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.$anonfun$visit$3$adapted(SignatureHelpProvider.scala:315)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:553)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:551)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:920)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:890)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.visit(SignatureHelpProvider.scala:315)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.traverse(SignatureHelpProvider.scala:303)
	at scala.meta.internal.pc.SignatureHelpProvider$MethodCallTraverser.fromTree(SignatureHelpProvider.scala:272)
	at scala.meta.internal.pc.SignatureHelpProvider.signatureHelp(SignatureHelpProvider.scala:27)

[0m2021.03.16 01:33:11 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:33:11 INFO  time: compiled root in 0.25s[0m
[0m2021.03.16 01:33:27 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:33:27 INFO  time: compiled root in 0.15s[0m
[0m2021.03.16 01:33:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:33:33 INFO  time: compiled root in 0.14s[0m
[0m2021.03.16 01:33:47 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:33:47 INFO  time: compiled root in 99ms[0m
[0m2021.03.16 01:34:06 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:34:06 INFO  time: compiled root in 0.6s[0m
[0m2021.03.16 01:34:06 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:34:06 INFO  time: compiled root in 0.1s[0m
Mar 16, 2021 1:34:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14221
[0m2021.03.16 01:37:48 INFO  compiling root (2 scala sources)[0m
[0m2021.03.16 01:37:48 INFO  time: compiled root in 0.78s[0m
[0m2021.03.16 01:37:48 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:37:49 INFO  time: compiled root in 0.27s[0m
[0m2021.03.16 01:43:19 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:43:19 INFO  time: compiled root in 0.77s[0m
Mar 16, 2021 1:50:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14316
Mar 16, 2021 1:50:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14333
[0m2021.03.16 01:52:10 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:52:10 INFO  Deduplicating compilation of root from bsp client 'Metals 0.10.0' (since 4h 30m 17.721s)[0m
[0m2021.03.16 01:52:10 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:52:10 INFO  time: compiled root in 58ms[0m
[0m2021.03.16 01:52:29 INFO  compiling root (2 scala sources)[0m
[0m2021.03.16 01:52:29 INFO  time: compiled root in 0.86s[0m
[0m2021.03.16 01:55:22 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:55:22 INFO  time: compiled root in 0.73s[0m
/*
 * Copyright (C) Lightbend Inc. <https://www.lightbend.com>
 */

package play.api.mvc

import java.lang.{ StringBuilder => JStringBuilder }
import java.net.URLEncoder
import java.nio.file.Files
import java.nio.file.Path
import java.time.format.DateTimeFormatter
import java.time.ZoneOffset
import java.time.ZonedDateTime

import akka.stream.scaladsl.FileIO
import akka.stream.scaladsl.Source
import akka.stream.scaladsl.StreamConverters
import akka.util.ByteString
import play.api.http.HeaderNames._
import play.api.http.FileMimeTypes
import play.api.http._
import play.api.i18n.Lang
import play.api.i18n.MessagesApi
import play.api.Logger
import play.api.Mode
import play.core.utils.CaseInsensitiveOrdered
import play.core.utils.HttpHeaderParameterEncoding

import scala.collection.JavaConverters._
import scala.collection.immutable.TreeMap
import scala.concurrent.ExecutionContext

/**
 * A simple HTTP response header, used for standard responses.
 *
 * @param status the response status, e.g. 200
 * @param _headers the HTTP headers
 * @param reasonPhrase the human-readable description of status, e.g. "Ok";
 *   if None, the default phrase for the status will be used
 */
final class ResponseHeader(
    val status: Int,
    _headers: Map[String, String] = Map.empty,
    val reasonPhrase: Option[String] = None
) {
  private[play] def this(status: Int, _headers: java.util.Map[String, String], reasonPhrase: Option[String]) =
    this(status, _headers.asScala.toMap, reasonPhrase)

  val headers: Map[String, String] = TreeMap[String, String]()(CaseInsensitiveOrdered) ++ _headers

  // validate headers so we know this response header is well formed
  for ((name, value) <- headers) {
    if (name eq null) throw new NullPointerException("Response header names cannot be null!")
    if (value eq null) throw new NullPointerException(s"Response header '$name' has null value!")
  }

  def copy(
      status: Int = status,
      headers: Map[String, String] = headers,
      reasonPhrase: Option[String] = reasonPhrase
  ): ResponseHeader =
    new ResponseHeader(status, headers, reasonPhrase)

  override def toString = s"$status, $headers"
  override def hashCode = (status, headers).hashCode
  override def equals(o: Any) = o match {
    case ResponseHeader(s, h, r) => (s, h, r).equals((status, headers, reasonPhrase))
    case _                       => false
  }

  def asJava: play.mvc.ResponseHeader = {
    new play.mvc.ResponseHeader(status, headers.asJava, reasonPhrase.orNull)
  }

  /**
   * INTERNAL API
   *
   * Appends to the comma-separated `Vary` header of this request
   */
  private[play] def varyWith(headerValues: String*): (String, String) = {
    val newValue = headers.get(VARY) match {
      case Some(existing) if existing.nonEmpty =>
        val existingSet: Set[String] = existing.split(",").iterator.map(_.trim.toLowerCase).toSet
        val newValuesToAdd           = headerValues.filterNot(v => existingSet.contains(v.trim.toLowerCase))
        s"$existing${newValuesToAdd.map(v => s",$v").mkString}"
      case _ =>
        headerValues.mkString(",")
    }
    VARY -> newValue
  }
}

object ResponseHeader {
  val basicDateFormatPattern = "EEE, dd MMM yyyy HH:mm:ss"
  val httpDateFormat: DateTimeFormatter =
    DateTimeFormatter
      .ofPattern(basicDateFormatPattern + " 'GMT'")
      .withLocale(java.util.Locale.ENGLISH)
      .withZone(ZoneOffset.UTC)

  def apply(
      status: Int,
      headers: Map[String, String] = Map.empty,
      reasonPhrase: Option[String] = None
  ): ResponseHeader =
    new ResponseHeader(status, headers)
  def unapply(rh: ResponseHeader): Option[(Int, Map[String, String], Option[String])] =
    if (rh eq null) None else Some((rh.status, rh.headers, rh.reasonPhrase))
}

object Result {

  /**
   * Logs a redirect warning for flashing (in dev mode) if the status code is not 3xx
   */
  @inline def warnFlashingIfNotRedirect(flash: Flash, header: ResponseHeader): Unit = {
    if (!flash.isEmpty && !Status.isRedirect(header.status)) {
      Logger("play")
        .forMode(Mode.Dev)
        .warn(
          s"You are using status code '${header.status}' with flashing, which should only be used with a redirect status!"
        )
    }
  }
}

/**
 * A simple result, which defines the response header and a body ready to send to the client.
 *
 * @param header the response header, which contains status code and HTTP headers
 * @param body the response body
 */
case class Result(
    header: ResponseHeader,
    body: HttpEntity,
    newSession: Option[Session] = None,
    newFlash: Option[Flash] = None,
    newCookies: Seq[Cookie] = Seq.empty
) {

  /**
   * Adds headers to this result.
   *
   * For example:
   * {{{
   * Ok("Hello world").withHeaders(ETAG -> "0")
   * }}}
   *
   * @param headers the headers to add to this result.
   * @return the new result
   */
  def withHeaders(headers: (String, String)*): Result = {
    copy(header = header.copy(headers = header.headers ++ headers))
  }

  /**
   * Add a header with a DateTime formatted using the default http date format
   *
   * @param headers the headers with a DateTime to add to this result.
   * @return the new result.
   */
  def withDateHeaders(headers: (String, ZonedDateTime)*): Result = {
    copy(header = header.copy(headers = header.headers ++ headers.map {
      case (name, dateTime) => (name, dateTime.format(ResponseHeader.httpDateFormat))
    }))
  }

  /**
   * Discards headers to this result.
   *
   * For example:
   * {{{
   * Ok("Hello world").discardingHeader(ETAG)
   * }}}
   *
   * @param name the header to discard from this result.
   * @return the new result
   */
  def discardingHeader(name: String): Result = {
    copy(header = header.copy(headers = header.headers - name))
  }

  /**
   * Adds cookies to this result. If the result already contains cookies then cookies with the same name in the new
   * list will override existing ones.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withCookies(Cookie("theme", "blue"))
   * }}}
   *
   * @param cookies the cookies to add to this result
   * @return the new result
   */
  def withCookies(cookies: Cookie*): Result = {
    val filteredCookies = newCookies.filter(cookie => !cookies.exists(_.name == cookie.name))
    if (cookies.isEmpty) this else copy(newCookies = filteredCookies ++ cookies)
  }

  /**
   * Discards cookies along this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).discardingCookies("theme")
   * }}}
   *
   * @param cookies the cookies to discard along to this result
   * @return the new result
   */
  def discardingCookies(cookies: DiscardingCookie*): Result = {
    withCookies(cookies.map(_.toCookie): _*)
  }

  /**
   * Sets a new session for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withSession(session + ("saidHello" -> "true"))
   * }}}
   *
   * @param session the session to set with this result
   * @return the new result
   */
  def withSession(session: Session): Result = copy(newSession = Some(session))

  /**
   * Sets a new session for this result, discarding the existing session.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withSession("saidHello" -> "yes")
   * }}}
   *
   * @param session the session to set with this result
   * @return the new result
   */
  def withSession(session: (String, String)*): Result = withSession(Session(session.toMap))

  /**
   * Discards the existing session for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).withNewSession
   * }}}
   *
   * @return the new result
   */
  def withNewSession: Result = withSession(Session())

  /**
   * Adds values to the flash scope for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).flashing(flash + ("success" -> "Done!"))
   * }}}
   *
   * @param flash the flash scope to set with this result
   * @return the new result
   */
  def flashing(flash: Flash): Result = {
    Result.warnFlashingIfNotRedirect(flash, header)
    copy(newFlash = Some(flash))
  }

  /**
   * Adds values to the flash scope for this result.
   *
   * For example:
   * {{{
   * Redirect(routes.Application.index()).flashing("success" -> "Done!")
   * }}}
   *
   * @param values the flash values to set with this result
   * @return the new result
   */
  def flashing(values: (String, String)*): Result = flashing(Flash(values.toMap))

  /**
   * Changes the result content type.
   *
   * For example:
   * {{{
   * Ok("<text>Hello world</text>").as("application/xml")
   * }}}
   *
   * @param contentType the new content type.
   * @return the new result
   */
  def as(contentType: String): Result = copy(body = body.as(contentType))

  /**
   * @param request Current request
   * @return The session carried by this result. Reads the request’s session if this result does not modify the session.
   */
  def session(implicit request: RequestHeader): Session = newSession.getOrElse(request.session)

  /**
   * Example:
   * {{{
   *   Ok.addingToSession("foo" -> "bar").addingToSession("baz" -> "bah")
   * }}}
   *
   * @param values (key -> value) pairs to add to this result’s session
   * @param request Current request
   * @return A copy of this result with `values` added to its session scope.
   */
  def addingToSession(values: (String, String)*)(implicit request: RequestHeader): Result =
    withSession(new Session(session.data ++ values.toMap))

  /**
   * Example:
   * {{{
   *   Ok.removingFromSession("foo")
   * }}}
   *
   * @param keys Keys to remove from session
   * @param request Current request
   * @return A copy of this result with `keys` removed from its session scope.
   */
  def removingFromSession(keys: String*)(implicit request: RequestHeader): Result =
    withSession(new Session(session.data -- keys))

  override def toString = s"Result(${header})"

  /**
   * Convert this result to a Java result.
   */
  def asJava: play.mvc.Result =
    new play.mvc.Result(
      header.asJava,
      body.asJava,
      newSession.map(_.asJava).orNull,
      newFlash.map(_.asJava).orNull,
      newCookies.map(_.asJava).asJava
    )

  /**
   * Encode the cookies into the Set-Cookie header. The session is always baked first, followed by the flash cookie,
   * followed by all the other cookies in order.
   */
  def bakeCookies(
      cookieHeaderEncoding: CookieHeaderEncoding = new DefaultCookieHeaderEncoding(),
      sessionBaker: CookieBaker[Session] = new DefaultSessionCookieBaker(),
      flashBaker: CookieBaker[Flash] = new DefaultFlashCookieBaker(),
      requestHasFlash: Boolean = false
  ): Result = {
    val allCookies = {
      val setCookieCookies = cookieHeaderEncoding.decodeSetCookieHeader(header.headers.getOrElse(SET_COOKIE, ""))
      val session = newSession.map { data =>
        if (data.isEmpty) sessionBaker.discard.toCookie else sessionBaker.encodeAsCookie(data)
      }
      val flash = newFlash
        .map { data =>
          if (data.isEmpty) flashBaker.discard.toCookie else flashBaker.encodeAsCookie(data)
        }
        .orElse {
          if (requestHasFlash) Some(flashBaker.discard.toCookie) else None
        }
      setCookieCookies ++ session ++ flash ++ newCookies
    }

    if (allCookies.isEmpty) {
      this
    } else {
      withHeaders(SET_COOKIE -> cookieHeaderEncoding.encodeSetCookieHeader(allCookies))
    }
  }
}

/**
 * A Codec handle the conversion of String to Byte arrays.
 *
 * @param charset The charset to be sent to the client.
 * @param encode The transformation function.
 */
case class Codec(charset: String)(val encode: String => ByteString, val decode: ByteString => String)

/**
 * Default Codec support.
 */
object Codec {

  /**
   * Create a Codec from an encoding already supported by the JVM.
   */
  def javaSupported(charset: String) =
    Codec(charset)(str => ByteString.apply(str, charset), bytes => bytes.decodeString(charset))

  /**
   * Codec for UTF-8
   */
  implicit val utf_8 = javaSupported("utf-8")

  /**
   * Codec for ISO-8859-1
   */
  val iso_8859_1 = javaSupported("iso-8859-1")
}

trait LegacyI18nSupport {

  /**
   * Adds convenient methods to handle the client-side language.
   *
   * This class exists only for backward compatibility.
   */
  implicit class ResultWithLang(result: Result)(implicit messagesApi: MessagesApi) {

    /**
     * Sets the user's language permanently for future requests by storing it in a cookie.
     *
     * For example:
     * {{{
     * implicit val lang = Lang("fr-FR")
     * Ok(Messages("hello.world")).withLang(lang)
     * }}}
     *
     * @param lang the language to store for the user
     * @return the new result
     */
    def withLang(lang: Lang): Result =
      messagesApi.setLang(result, lang)

    /**
     * Clears the user's language by discarding the language cookie set by withLang
     *
     * For example:
     * {{{
     * Ok(Messages("hello.world")).withoutLang
     * }}}
     *
     * @return the new result
     */
    def clearingLang: Result =
      messagesApi.clearLang(result)
  }
}

/** Helper utilities to generate results. */
object Results extends Results with LegacyI18nSupport {
  private[mvc] final val logger = Logger(getClass)

  /** Empty result, i.e. nothing to send. */
  case class EmptyContent()

  /**
   * Encodes and adds the query params to the given url
   *
   * @param url
   * @param queryStringParams
   * @return
   */
  private[play] def addQueryStringParams(url: String, queryStringParams: Map[String, Seq[String]]): String = {
    if (queryStringParams.isEmpty) {
      url
    } else {
      val queryString: String = queryStringParams
        .flatMap {
          case (key, values) =>
            val encodedKey = URLEncoder.encode(key, "utf-8")
            values.map(value => s"$encodedKey=${URLEncoder.encode(value, "utf-8")}")
        }
        .mkString("&")

      url + (if (url.contains("?")) "&" else "?") + queryString
    }
  }

  /**
   * Creates a {@code Content-Disposition} header.<br>
   * According to RFC 6266 (Section 4.2) there is no need to send the header {@code "Content-Disposition: inline"}.
   * Therefore if the header generated by this method ends up being exactly that header (when passing {@code inline = true}
   * and {@code None} as {@code name}), an empty Map ist returned.
   *
   * @param inline If the content should be rendered inline or as attachment.
   * @param name The name of the resource, usually displayed in a file download dialog.
   * @return a map with a {@code Content-Disposition} header entry or an empty map if explained conditions apply.
   * @see [[https://tools.ietf.org/html/rfc6266#section-4.2]]
   */
  def contentDispositionHeader(inline: Boolean, name: Option[String]): Map[String, String] =
    if (!inline || name.exists(_.nonEmpty))
      Map(
        CONTENT_DISPOSITION -> {
          val builder = new JStringBuilder
          builder.append(if (inline) "inline" else "attachment")
          name.foreach(filename => {
            builder.append("; ")
            HttpHeaderParameterEncoding.encodeToBuilder("filename", filename, builder)
          })
          builder.toString
        }
      )
    else Map.empty
}

/** Helper utilities to generate results. */
trait Results {
  import play.api.http.Status._

  /**
   * Generates default `Result` from a content type, headers and content.
   *
   * @param status the HTTP response status, e.g ‘200 OK’
   */
  class Status(status: Int) extends Result(header = ResponseHeader(status), body = HttpEntity.NoEntity) {

    /**
     * Set the result's content.
     *
     * @param content The content to send.
     */
    def apply[C](content: C)(implicit writeable: Writeable[C]): Result = {
      Result(
        header,
        writeable.toEntity(content)
      )
    }

    private def streamFile(file: Source[ByteString, _], name: Option[String], length: Option[Long], inline: Boolean)(
        implicit fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        ResponseHeader(
          status,
          Results.contentDispositionHeader(inline, name)
        ),
        HttpEntity.Streamed(
          file,
          length,
          name.flatMap(fileMimeTypes.forFileName).orElse(Some(play.api.http.ContentTypes.BINARY))
        )
      )
    }

    /**
     * Send a file.
     *
     * @param content The file to send.
     * @param inline Use Content-Disposition inline or attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     * @param onClose Useful in order to perform cleanup operations (e.g. deleting a temporary file generated for a download).
     */
    def sendFile(
        content: java.io.File,
        inline: Boolean = true,
        fileName: java.io.File => Option[String] = Option(_).map(_.getName),
        onClose: () => Unit = () => ()
    )(implicit ec: ExecutionContext, fileMimeTypes: FileMimeTypes): Result = {
      sendPath(content.toPath, inline, (p: Path) => fileName(p.toFile), onClose)
    }

    /**
     * Send a path.
     *
     * @param content The path to send.
     * @param inline Use Content-Disposition inline or attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     * @param onClose Useful in order to perform cleanup operations (e.g. deleting a temporary file generated for a download).
     */
    def sendPath(
        content: Path,
        inline: Boolean = true,
        fileName: Path => Option[String] = Option(_).map(_.getFileName.toString),
        onClose: () => Unit = () => ()
    )(implicit ec: ExecutionContext, fileMimeTypes: FileMimeTypes): Result = {
      val io = FileIO
        .fromPath(content)
        .mapMaterializedValue(_.onComplete { _ =>
          onClose()
        })
      streamFile(io, fileName(content), Some(Files.size(content)), inline)
    }

    /**
     * Send the given resource from the given classloader.
     *
     * @param resource The path of the resource to load.
     * @param classLoader The classloader to load it from, defaults to the classloader for this class.
     * @param inline Whether it should be served as an inline file, or as an attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     * @param onClose Useful in order to perform cleanup operations (e.g. deleting a temporary file generated for a download).
     */
    def sendResource(
        resource: String,
        classLoader: ClassLoader = Results.getClass.getClassLoader,
        inline: Boolean = true,
        fileName: String => Option[String] = Option(_).map(_.split('/').last),
        onClose: () => Unit = () => ()
    )(implicit ec: ExecutionContext, fileMimeTypes: FileMimeTypes): Result = {
      val stream = classLoader.getResourceAsStream(resource)
      val io = StreamConverters
        .fromInputStream(() => stream)
        .mapMaterializedValue(_.onComplete { _ =>
          onClose()
        })
      streamFile(io, fileName(resource), Some(stream.available()), inline)
    }

    /**
     * Feed the content as the response, using chunked transfer encoding.
     *
     * Chunked transfer encoding is only supported for HTTP 1.1 clients.  If the client is an HTTP 1.0 client, Play will
     * instead return a 505 error code.
     *
     * Chunked encoding allows the server to send a response where the content length is not known, or for potentially
     * infinite streams, while still allowing the connection to be kept alive and reused for the next request.
     *
     * @param content Source providing the content to stream.
     * @param contentType an optional content type.
     */
    def chunked[C](content: Source[C, _], contentType: Option[String] = None)(
        implicit writeable: Writeable[C]
    ): Result = {
      Result(
        header = header,
        body = HttpEntity
          .Chunked(content.map(c => HttpChunk.Chunk(writeable.transform(c))), contentType.orElse(writeable.contentType))
      )
    }

    /**
     * Feed the content as the response, using chunked transfer encoding.
     *
     * Chunked transfer encoding is only supported for HTTP 1.1 clients.  If the client is an HTTP 1.0 client, Play will
     * instead return a 505 error code.
     *
     * Chunked encoding allows the server to send a response where the content length is not known, or for potentially
     * infinite streams, while still allowing the connection to be kept alive and reused for the next request.
     *
     * @param content Source providing the content to stream.
     * @param inline If the content should be rendered inline or as attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to the content-type of the
     *      {@code implicit writeable} if unknown.
     */
    def chunked[C](content: Source[C, _], inline: Boolean, fileName: Option[String])(
        implicit writeable: Writeable[C],
        fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        header = header.copy(headers = header.headers ++ Results.contentDispositionHeader(inline, fileName)),
        body = HttpEntity.Chunked(
          content.map(c => HttpChunk.Chunk(writeable.transform(c))),
          fileName.flatMap(fileMimeTypes.forFileName).orElse(writeable.contentType)
        )
      )
    }

    /**
     * Feed the content as the response, using a streamed entity.
     *
     * It will use the given Content-Type, but if is not present, then it fallsback
     * to use the [[Writeable]] contentType.
     *
     * @param content Source providing the content to stream.
     * @param contentLength an optional content length.
     * @param contentType an optional content type.
     */
    def streamed[C](content: Source[C, _], contentLength: Option[Long], contentType: Option[String] = None)(
        implicit writeable: Writeable[C]
    ): Result = {
      Result(
        header = header,
        body = HttpEntity
          .Streamed(content.map(c => writeable.transform(c)), contentLength, contentType.orElse(writeable.contentType))
      )
    }

    /**
     * Feed the content as the response, using a streamed entity.
     *
     * It will use the given Content-Type, but if is not present, then it fallsback
     * to use the [[Writeable]] contentType.
     *
     * @param content Source providing the content to stream.
     * @param contentLength an optional content length.
     * @param inline If the content should be rendered inline or as attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to the content-type of the
     *      {@code implicit writeable} if unknown.
     */
    def streamed[C](content: Source[C, _], contentLength: Option[Long], inline: Boolean, fileName: Option[String])(
        implicit writeable: Writeable[C],
        fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        header = header.copy(headers = header.headers ++ Results.contentDispositionHeader(inline, fileName)),
        body = HttpEntity.Streamed(
          content.map(c => writeable.transform(c)),
          contentLength,
          fileName.flatMap(fileMimeTypes.forFileName).orElse(writeable.contentType)
        )
      )
    }

    /**
     * Send an HTTP entity with this status.
     *
     * @param entity The entity to send.
     */
    def sendEntity(entity: HttpEntity): Result = {
      Result(
        header = header,
        body = entity
      )
    }

    /**
     * Send an HTTP entity with this status.
     *
     * @param entity The entity to send.
     * @param inline If the content should be rendered inline or as attachment.
     * @param fileName Function to retrieve the file name rendered in the {@code Content-Disposition} header. By default the name
     *      of the file is used. The response will also automatically include the MIME type in the {@code Content-Type} header
     *      deducing it from this file name if the {@code implicit fileMimeTypes} includes it or fallback to {@code application/octet-stream}
     *      if unknown.
     */
    def sendEntity(entity: HttpEntity, inline: Boolean, fileName: Option[String])(
        implicit fileMimeTypes: FileMimeTypes
    ): Result = {
      Result(
        header = header.copy(headers = header.headers ++ Results.contentDispositionHeader(inline, fileName)),
        body = entity
      ).as(fileName.flatMap(fileMimeTypes.forFileName).getOrElse(play.api.http.ContentTypes.BINARY))
    }
  }

  /** Generates a ‘100 Continue’ result. */
  val Continue = Result(header = ResponseHeader(CONTINUE), body = HttpEntity.NoEntity)

  /** Generates a ‘101 Switching Protocols’ result. */
  val SwitchingProtocols = Result(header = ResponseHeader(SWITCHING_PROTOCOLS), body = HttpEntity.NoEntity)

  /** Generates a ‘200 OK’ result. */
  val Ok = new Status(OK)

  /** Generates a ‘201 CREATED’ result. */
  val Created = new Status(CREATED)

  /** Generates a ‘202 ACCEPTED’ result. */
  val Accepted = new Status(ACCEPTED)

  /** Generates a ‘203 NON_AUTHORITATIVE_INFORMATION’ result. */
  val NonAuthoritativeInformation = new Status(NON_AUTHORITATIVE_INFORMATION)

  /** Generates a ‘204 NO_CONTENT’ result. */
  val NoContent = Result(header = ResponseHeader(NO_CONTENT), body = HttpEntity.NoEntity)

  /** Generates a ‘205 RESET_CONTENT’ result. */
  val ResetContent = Result(header = ResponseHeader(RESET_CONTENT), body = HttpEntity.NoEntity)

  /** Generates a ‘206 PARTIAL_CONTENT’ result. */
  val PartialContent = new Status(PARTIAL_CONTENT)

  /** Generates a ‘207 MULTI_STATUS’ result. */
  val MultiStatus = new Status(MULTI_STATUS)

  /**
   * Generates a ‘301 MOVED_PERMANENTLY’ simple result.
   *
   * @param url the URL to redirect to
   */
  def MovedPermanently(url: String): Result = Redirect(url, MOVED_PERMANENTLY)

  /**
   * Generates a ‘302 FOUND’ simple result.
   *
   * @param url the URL to redirect to
   */
  def Found(url: String): Result = Redirect(url, FOUND)

  /**
   * Generates a ‘303 SEE_OTHER’ simple result.
   *
   * @param url the URL to redirect to
   */
  def SeeOther(url: String): Result = Redirect(url, SEE_OTHER)

  /** Generates a ‘304 NOT_MODIFIED’ result. */
  val NotModified = Result(header = ResponseHeader(NOT_MODIFIED), body = HttpEntity.NoEntity)

  /**
   * Generates a ‘307 TEMPORARY_REDIRECT’ simple result.
   *
   * @param url the URL to redirect to
   */
  def TemporaryRedirect(url: String): Result = Redirect(url, TEMPORARY_REDIRECT)

  /**
   * Generates a ‘308 PERMANENT_REDIRECT’ simple result.
   *
   * @param url the URL to redirect to
   */
  def PermanentRedirect(url: String): Result = Redirect(url, PERMANENT_REDIRECT)

  /** Generates a ‘400 BAD_REQUEST’ result. */
  val BadRequest = new Status(BAD_REQUEST)

  /** Generates a ‘401 UNAUTHORIZED’ result. */
  val Unauthorized = new Status(UNAUTHORIZED)

  /** Generates a ‘402 PAYMENT_REQUIRED’ result. */
  val PaymentRequired = new Status(PAYMENT_REQUIRED)

  /** Generates a ‘403 FORBIDDEN’ result. */
  val Forbidden = new Status(FORBIDDEN)

  /** Generates a ‘404 NOT_FOUND’ result. */
  val NotFound = new Status(NOT_FOUND)

  /** Generates a ‘405 METHOD_NOT_ALLOWED’ result. */
  val MethodNotAllowed = new Status(METHOD_NOT_ALLOWED)

  /** Generates a ‘406 NOT_ACCEPTABLE’ result. */
  val NotAcceptable = new Status(NOT_ACCEPTABLE)

  /** Generates a ‘408 REQUEST_TIMEOUT’ result. */
  val RequestTimeout = new Status(REQUEST_TIMEOUT)

  /** Generates a ‘409 CONFLICT’ result. */
  val Conflict = new Status(CONFLICT)

  /** Generates a ‘410 GONE’ result. */
  val Gone = new Status(GONE)

  /** Generates a ‘412 PRECONDITION_FAILED’ result. */
  val PreconditionFailed = new Status(PRECONDITION_FAILED)

  /** Generates a ‘413 REQUEST_ENTITY_TOO_LARGE’ result. */
  val EntityTooLarge = new Status(REQUEST_ENTITY_TOO_LARGE)

  /** Generates a ‘414 REQUEST_URI_TOO_LONG’ result. */
  val UriTooLong = new Status(REQUEST_URI_TOO_LONG)

  /** Generates a ‘415 UNSUPPORTED_MEDIA_TYPE’ result. */
  val UnsupportedMediaType = new Status(UNSUPPORTED_MEDIA_TYPE)

  /** Generates a ‘417 EXPECTATION_FAILED’ result. */
  val ExpectationFailed = new Status(EXPECTATION_FAILED)

  /** Generates a ‘418 IM_A_TEAPOT’ result. */
  val ImATeapot = new Status(IM_A_TEAPOT)

  /** Generates a ‘422 UNPROCESSABLE_ENTITY’ result. */
  val UnprocessableEntity = new Status(UNPROCESSABLE_ENTITY)

  /** Generates a ‘423 LOCKED’ result. */
  val Locked = new Status(LOCKED)

  /** Generates a ‘424 FAILED_DEPENDENCY’ result. */
  val FailedDependency = new Status(FAILED_DEPENDENCY)

  /** Generates a ‘428 PRECONDITION_REQUIRED’ result. */
  val PreconditionRequired = new Status(PRECONDITION_REQUIRED)

  /** Generates a ‘429 TOO_MANY_REQUESTS’ result. */
  val TooManyRequests = new Status(TOO_MANY_REQUESTS)

  /** Generates a ‘431 REQUEST_HEADER_FIELDS_TOO_LARGE’ result. */
  val RequestHeaderFieldsTooLarge = new Status(REQUEST_HEADER_FIELDS_TOO_LARGE)

  /** Generates a ‘500 INTERNAL_SERVER_ERROR’ result. */
  val InternalServerError = new Status(INTERNAL_SERVER_ERROR)

  /** Generates a ‘501 NOT_IMPLEMENTED’ result. */
  val NotImplemented = new Status(NOT_IMPLEMENTED)

  /** Generates a ‘502 BAD_GATEWAY’ result. */
  val BadGateway = new Status(BAD_GATEWAY)

  /** Generates a ‘503 SERVICE_UNAVAILABLE’ result. */
  val ServiceUnavailable = new Status(SERVICE_UNAVAILABLE)

  /** Generates a ‘504 GATEWAY_TIMEOUT’ result. */
  val GatewayTimeout = new Status(GATEWAY_TIMEOUT)

  /** Generates a ‘505 HTTP_VERSION_NOT_SUPPORTED’ result. */
  val HttpVersionNotSupported = new Status(HTTP_VERSION_NOT_SUPPORTED)

  /** Generates a ‘507 INSUFFICIENT_STORAGE’ result. */
  val InsufficientStorage = new Status(INSUFFICIENT_STORAGE)

  /** Generates a ‘511 NETWORK_AUTHENTICATION_REQUIRED’ result. */
  val NetworkAuthenticationRequired = new Status(NETWORK_AUTHENTICATION_REQUIRED)

  /**
   * Generates a simple result.
   *
   * @param code the status code
   */
  def Status(code: Int) = new Status(code)

  /**
   * Generates a redirect simple result.
   *
   * @param url the URL to redirect to
   * @param statusCode HTTP status
   */
  def Redirect(url: String, statusCode: Int): Result = Redirect(url, Map.empty, statusCode)

  /**
   * Generates a redirect simple result.
   *
   * @param url the URL to redirect to
   * @param queryStringParams queryString parameters to add to the queryString
   * @param status HTTP status for redirect, such as SEE_OTHER, MOVED_TEMPORARILY or MOVED_PERMANENTLY
   */
  def Redirect(url: String, queryStringParams: Map[String, Seq[String]] = Map.empty, status: Int = SEE_OTHER) = {
    if (!play.api.http.Status.isRedirect(status)) {
      Results.logger
        .forMode(Mode.Dev)
        .warn(s"You are using status code $status which is not a redirect code!")
    }
    val fullUrl: String = Results.addQueryStringParams(url, queryStringParams)
    Status(status).withHeaders(LOCATION -> fullUrl)
  }

  /**
   * Generates a redirect simple result.
   *
   * @param call Call defining the URL to redirect to, which typically comes from the reverse router
   */
  def Redirect(call: Call): Result = Redirect(call.path)

  /**
   * Generates a redirect simple result.
   *
   * @param call Call defining the URL to redirect to, which typically comes from the reverse router
   * @param status HTTP status for redirect, such as SEE_OTHER, MOVED_TEMPORARILY or MOVED_PERMANENTLY
   */
  def Redirect(call: Call, status: Int): Result = Redirect(call.path, Map.empty, status)
}

[0m2021.03.16 01:57:24 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:57:24 INFO  time: compiled root in 0.12s[0m
[0m2021.03.16 01:57:33 INFO  compiling root (1 scala source)[0m
[0m2021.03.16 01:57:33 INFO  time: compiled root in 0.71s[0m
